# ğŸ­ è¡Œä¸šé€‚åº”æ€§è¯„ä¼°å™¨ (Industry Adaptability Assessor)
# Prompt-Create-3.0 ä¸“ä¸šæ¨¡å— | ç‰ˆæœ¬ï¼š3.0.1

## ğŸ¯ æ¨¡å—æ ¸å¿ƒå®šä½

**è¡Œä¸šé€‚åº”æ€§è¯„ä¼°å™¨**æ˜¯Prompt-Create-3.0ç§‘å­¦éªŒè¯å†³ç­–ç³»ç»Ÿçš„è¡Œä¸šåŒ¹é…å¼•æ“ï¼Œä¸“é—¨è´Ÿè´£è¯„ä¼°å€™é€‰æç¤ºè¯åœ¨ä¸åŒè¡Œä¸šç¯å¢ƒä¸­çš„é€‚åº”æ€§å’ŒåŒ¹é…åº¦ï¼Œé€šè¿‡å¤šç»´åº¦é‡åŒ–åˆ†æç¡®ä¿æç¤ºè¯èƒ½å¤Ÿå®Œç¾èå…¥ç‰¹å®šè¡Œä¸šçš„å·¥ä½œæµç¨‹ã€æ–‡åŒ–ç¯å¢ƒå’Œä¸“ä¸šè¦æ±‚ã€‚

### æ ¸å¿ƒä½¿å‘½
> **ç²¾å‡†é‡åŒ–è¡Œä¸šé€‚é…åº¦ï¼Œç¡®ä¿æ¯ä¸ªæç¤ºè¯éƒ½èƒ½åœ¨ç›®æ ‡è¡Œä¸šä¸­å‘æŒ¥æœ€å¤§ä»·å€¼**

---

## ğŸŒ åäºŒå¤§è¡Œä¸šé€‚åº”æ€§è¯„ä¼°ä½“ç³»

### ğŸ’° **è¡Œä¸š1: é‡‘èæœåŠ¡ä¸š (Financial Services)**

#### ğŸ”¹ **è¡Œä¸šç‰¹å¾åˆ†æ**
```yaml
è¡Œä¸šæ ¸å¿ƒç‰¹å¾:
  ç›‘ç®¡ç¯å¢ƒ: ä¸¥æ ¼ç›‘ç®¡ã€åˆè§„è¦æ±‚é«˜ã€é£é™©æ§åˆ¶ä¸¥å¯†
  ä¸“ä¸šè¦æ±‚: é«˜åº¦ä¸“ä¸šåŒ–ã€æ•°æ®é©±åŠ¨ã€ç²¾ç¡®è®¡ç®—
  å·¥ä½œèŠ‚å¥: å¿«èŠ‚å¥ã€é«˜å‹åŠ›ã€æ—¶æ•ˆæ€§å¼º
  æ–‡åŒ–ç‰¹è‰²: ä¿å®ˆç¨³å¥ã€ç»“æœå¯¼å‘ã€è´£ä»»é‡å¤§
  
æŠ€æœ¯ç¯å¢ƒ:
  æ•°æ®æ•æ„Ÿæ€§: æé«˜ï¼Œæ¶‰åŠå®¢æˆ·éšç§å’Œå•†ä¸šæœºå¯†
  ç³»ç»Ÿç¨³å®šæ€§: è¦æ±‚99.9%ä»¥ä¸Šçš„å¯ç”¨æ€§ 
  å®‰å…¨æ ‡å‡†: é‡‘èçº§å®‰å…¨è¦æ±‚ï¼Œå¤šé‡è®¤è¯
  åˆè§„æ¡†æ¶: é“¶ä¿ç›‘ä¼šã€è¯ç›‘ä¼šã€äººæ°‘é“¶è¡Œç­‰ç›‘ç®¡

å…³é”®æˆåŠŸå› ç´ :
  é£é™©æ§åˆ¶èƒ½åŠ›: è¯†åˆ«ã€è¯„ä¼°ã€æ§åˆ¶å„ç±»é£é™©
  åˆè§„æ‰§è¡ŒåŠ›: ä¸¥æ ¼éµå¾ªç›‘ç®¡è¦æ±‚å’Œæ³•å¾‹æ³•è§„
  ä¸“ä¸šæƒå¨æ€§: å…·å¤‡æ·±åšçš„é‡‘èä¸“ä¸šçŸ¥è¯†
  æ•°æ®å‡†ç¡®æ€§: ç¡®ä¿æ•°æ®å’Œåˆ†æçš„é«˜åº¦å‡†ç¡®æ€§

é€‚åº”æ€§è¯„ä¼°ç»´åº¦:
  åˆè§„é€‚é…åº¦: æ˜¯å¦ç¬¦åˆé‡‘èç›‘ç®¡è¦æ±‚ (æƒé‡: 25%)
  ä¸“ä¸šåŒ¹é…åº¦: é‡‘èä¸“ä¸šçŸ¥è¯†çš„å‡†ç¡®æ€§ (æƒé‡: 20%)
  é£é™©æ§åˆ¶åº¦: é£é™©è¯†åˆ«å’Œæ§åˆ¶èƒ½åŠ› (æƒé‡: 20%)
  å®‰å…¨ä¿éšœåº¦: ä¿¡æ¯å®‰å…¨å’Œéšç§ä¿æŠ¤ (æƒé‡: 15%)
  æ•ˆç‡å®ç”¨æ€§: æå‡å·¥ä½œæ•ˆç‡çš„ç¨‹åº¦ (æƒé‡: 10%)
  åˆ›æ–°ä»·å€¼åº¦: ä¸ºä¸šåŠ¡å¸¦æ¥çš„åˆ›æ–°ä»·å€¼ (æƒé‡: 10%)
```

#### ğŸ”¹ **è¯„ä¼°ç®—æ³•æ¡†æ¶**
```python
class FinancialServicesAdaptabilityAssessor:
    """é‡‘èæœåŠ¡ä¸šé€‚åº”æ€§è¯„ä¼°å™¨"""
    
    def __init__(self):
        self.regulatory_standards = {
            'china_banking_regulatory': ['é“¶ä¿ç›‘ä¼šç›‘ç®¡è¦æ±‚', 'é“¶è¡Œä¸šåŠ¡è§„èŒƒ'],
            'securities_regulatory': ['è¯ç›‘ä¼šè§„å®š', 'è¯åˆ¸æŠ•èµ„è§„èŒƒ'],
            'insurance_regulatory': ['ä¿é™©ä¸šç›‘ç®¡', 'ä¿é™©äº§å“è§„èŒƒ'],
            'fintech_regulatory': ['é‡‘èç§‘æŠ€ç›‘ç®¡', 'æ•°å­—é‡‘èè§„èŒƒ']
        }
        
        self.professional_knowledge_base = {
            'banking': ['å•†ä¸šé“¶è¡Œä¸šåŠ¡', 'é£é™©ç®¡ç†', 'èµ„äº§è´Ÿå€ºç®¡ç†'],
            'securities': ['è¯åˆ¸æŠ•èµ„', 'èµ„æœ¬å¸‚åœº', 'æŠ•èµ„åˆ†æ'],
            'insurance': ['ä¿é™©åŸç†', 'ç²¾ç®—ç§‘å­¦', 'ä¿é™©äº§å“è®¾è®¡'],
            'fintech': ['é‡‘èç§‘æŠ€', 'FinTechåˆ›æ–°', 'æ•°å­—åŒ–è½¬å‹']
        }
        
    def assess_financial_adaptability(self, prompt_candidate):
        """è¯„ä¼°é‡‘èè¡Œä¸šé€‚åº”æ€§"""
        assessment_result = {
            'overall_adaptability_score': 0.0,
            'dimension_scores': {},
            'compliance_analysis': {},
            'risk_assessment': {},
            'professional_validation': {},
            'implementation_feasibility': {}
        }
        
        # 1. åˆè§„é€‚é…åº¦è¯„ä¼° (25%)
        compliance_score = self.assess_compliance_alignment(prompt_candidate)
        assessment_result['dimension_scores']['compliance'] = compliance_score
        
        # 2. ä¸“ä¸šåŒ¹é…åº¦è¯„ä¼° (20%)
        professional_score = self.assess_professional_knowledge_alignment(prompt_candidate)
        assessment_result['dimension_scores']['professional'] = professional_score
        
        # 3. é£é™©æ§åˆ¶åº¦è¯„ä¼° (20%)
        risk_control_score = self.assess_risk_control_capability(prompt_candidate)
        assessment_result['dimension_scores']['risk_control'] = risk_control_score
        
        # 4. å®‰å…¨ä¿éšœåº¦è¯„ä¼° (15%)
        security_score = self.assess_security_protection(prompt_candidate)
        assessment_result['dimension_scores']['security'] = security_score
        
        # 5. æ•ˆç‡å®ç”¨æ€§è¯„ä¼° (10%)
        efficiency_score = self.assess_efficiency_practicality(prompt_candidate)
        assessment_result['dimension_scores']['efficiency'] = efficiency_score
        
        # 6. åˆ›æ–°ä»·å€¼åº¦è¯„ä¼° (10%)
        innovation_score = self.assess_innovation_value(prompt_candidate)
        assessment_result['dimension_scores']['innovation'] = innovation_score
        
        # 7. ç»¼åˆé€‚åº”æ€§è¯„åˆ†
        assessment_result['overall_adaptability_score'] = self.calculate_weighted_score({
            'compliance': (compliance_score, 0.25),
            'professional': (professional_score, 0.20),
            'risk_control': (risk_control_score, 0.20),
            'security': (security_score, 0.15),
            'efficiency': (efficiency_score, 0.10),
            'innovation': (innovation_score, 0.10)
        })
        
        return assessment_result
    
    def assess_compliance_alignment(self, prompt_candidate):
        """è¯„ä¼°åˆè§„é€‚é…åº¦"""
        compliance_indicators = {
            'regulatory_terminology_usage': self.check_regulatory_terminology(prompt_candidate),
            'compliance_process_alignment': self.verify_compliance_processes(prompt_candidate),
            'legal_requirement_adherence': self.validate_legal_requirements(prompt_candidate),
            'reporting_standard_compliance': self.check_reporting_standards(prompt_candidate)
        }
        
        # è®¡ç®—åˆè§„è¯„åˆ†
        compliance_score = sum(compliance_indicators.values()) / len(compliance_indicators)
        
        return {
            'score': compliance_score,
            'details': compliance_indicators,
            'risk_level': self.assess_compliance_risk(compliance_indicators),
            'improvement_suggestions': self.generate_compliance_improvements(compliance_indicators)
        }
```

### ğŸ¥ **è¡Œä¸š2: åŒ»ç–—å¥åº·ä¸š (Healthcare)**

#### ğŸ”¹ **è¡Œä¸šç‰¹å¾åˆ†æ**
```yaml
è¡Œä¸šæ ¸å¿ƒç‰¹å¾:
  ä¸“ä¸šé—¨æ§›: æé«˜çš„ä¸“ä¸šå‡†å…¥é—¨æ§›ï¼Œéœ€è¦ä¸“ä¸šèµ„è´¨
  è´£ä»»é‡å¤§: ç›´æ¥å…³ç³»ç”Ÿå‘½å¥åº·ï¼Œå®¹é”™ç‡æä½
  è¯æ®å¯¼å‘: å¾ªè¯åŒ»å­¦ï¼ŒåŸºäºç§‘å­¦è¯æ®çš„å†³ç­–
  äººæ–‡å…³æ€€: åŒ»è€…ä»å¿ƒï¼Œæ³¨é‡æ‚£è€…ä½“éªŒå’Œå…³æ€€

æŠ€æœ¯ç¯å¢ƒ:
  æ•°æ®éšç§: æ‚£è€…éšç§ä¿æŠ¤ï¼ŒHIPAAç­‰æ³•è§„
  åŒ»ç–—è®¾å¤‡: é«˜ç²¾åº¦åŒ»ç–—è®¾å¤‡ï¼ŒæŠ€æœ¯å…ˆè¿›æ€§
  ä¿¡æ¯ç³»ç»Ÿ: HISã€PACSã€LISç­‰ä¸“ä¸šç³»ç»Ÿ
  è¿œç¨‹åŒ»ç–—: äº’è”ç½‘+åŒ»ç–—ï¼Œè¿œç¨‹è¯Šç–—æŠ€æœ¯

å…³é”®æˆåŠŸå› ç´ :
  åŒ»å­¦å‡†ç¡®æ€§: åŒ»å­¦çŸ¥è¯†å’Œè¯Šç–—ä¿¡æ¯çš„å‡†ç¡®æ€§
  å®‰å…¨å¯é æ€§: ç¡®ä¿æ‚£è€…å®‰å…¨ï¼Œå‡å°‘åŒ»ç–—é£é™©
  ä¼¦ç†åˆè§„æ€§: ç¬¦åˆåŒ»ç–—ä¼¦ç†å’Œæ³•å¾‹æ³•è§„
  äººæ–‡å…³æ€€åº¦: ä½“ç°åŒ»å­¦äººæ–‡ç²¾ç¥å’Œæ‚£è€…å…³æ€€

é€‚åº”æ€§è¯„ä¼°ç»´åº¦:
  åŒ»å­¦å‡†ç¡®æ€§: åŒ»å­¦çŸ¥è¯†çš„å‡†ç¡®æ€§å’Œæƒå¨æ€§ (æƒé‡: 30%)
  å®‰å…¨å¯é æ€§: åŒ»ç–—å®‰å…¨å’Œé£é™©æ§åˆ¶èƒ½åŠ› (æƒé‡: 25%)
  ä¼¦ç†åˆè§„æ€§: åŒ»ç–—ä¼¦ç†å’Œæ³•è§„ç¬¦åˆåº¦ (æƒé‡: 20%)
  äººæ–‡å…³æ€€åº¦: æ‚£è€…ä½“éªŒå’Œäººæ–‡å…³æ€€ (æƒé‡: 15%)
  æŠ€æœ¯å…ˆè¿›æ€§: åŒ»ç–—æŠ€æœ¯çš„å…ˆè¿›ç¨‹åº¦ (æƒé‡: 10%)
```

### ğŸ“ **è¡Œä¸š3: æ•™è‚²åŸ¹è®­ä¸š (Education & Training)**

#### ğŸ”¹ **è¡Œä¸šç‰¹å¾åˆ†æ**
```yaml
è¡Œä¸šæ ¸å¿ƒç‰¹å¾:
  è‚²äººå¯¼å‘: ä»¥åŸ¹å…»äººæ‰ä¸ºæ ¸å¿ƒç›®æ ‡
  å› ææ–½æ•™: ä¸ªæ€§åŒ–æ•™å­¦ï¼Œé€‚åº”ä¸åŒå­¦ä¹ è€…
  å¾ªåºæ¸è¿›: éµå¾ªæ•™å­¦è§„å¾‹ï¼Œèºæ—‹å¼ä¸Šå‡
  å¸ˆè€…é£èŒƒ: æ•™å¸ˆèŒä¸šé“å¾·ï¼Œä¸ºäººå¸ˆè¡¨

æŠ€æœ¯ç¯å¢ƒ:
  åœ¨çº¿æ•™è‚²: äº’è”ç½‘+æ•™è‚²ï¼Œæ•°å­—åŒ–æ•™å­¦
  æ™ºèƒ½åŒ–æ•™å­¦: AIè¾…åŠ©æ•™å­¦ï¼Œä¸ªæ€§åŒ–æ¨è
  è¯„æµ‹ç³»ç»Ÿ: å­¦ä¹ æ•ˆæœè¯„ä¼°ï¼Œèƒ½åŠ›æµ‹è¯•
  æ•™å­¦èµ„æº: ä¸°å¯Œçš„æ•°å­—åŒ–æ•™å­¦èµ„æº

å…³é”®æˆåŠŸå› ç´ :
  æ•™å­¦æœ‰æ•ˆæ€§: æ•™å­¦æ–¹æ³•çš„ç§‘å­¦æ€§å’Œæœ‰æ•ˆæ€§
  å­¦ä¹ å‹å¥½æ€§: é€‚åˆå­¦ä¹ è€…è®¤çŸ¥ç‰¹ç‚¹
  å†…å®¹æƒå¨æ€§: æ•™å­¦å†…å®¹çš„å‡†ç¡®æ€§å’Œæƒå¨æ€§
  æ¿€åŠ±æœºåˆ¶: æ¿€å‘å­¦ä¹ å…´è¶£å’ŒåŠ¨æœº

é€‚åº”æ€§è¯„ä¼°ç»´åº¦:
  æ•™å­¦æœ‰æ•ˆæ€§: æ•™å­¦æ–¹æ³•å’Œæ•ˆæœ (æƒé‡: 25%)
  å­¦ä¹ å‹å¥½æ€§: è®¤çŸ¥è´Ÿè·å’Œå­¦ä¹ ä½“éªŒ (æƒé‡: 20%)
  å†…å®¹æƒå¨æ€§: çŸ¥è¯†å†…å®¹çš„å‡†ç¡®æ€§ (æƒé‡: 20%)
  ä¸ªæ€§åŒ–ç¨‹åº¦: é€‚åº”ä¸åŒå­¦ä¹ è€…éœ€æ±‚ (æƒé‡: 15%)
  æ¿€åŠ±æ•ˆæœ: å­¦ä¹ åŠ¨æœºæ¿€å‘èƒ½åŠ› (æƒé‡: 10%)
  æŠ€æœ¯èåˆåº¦: æ•™è‚²æŠ€æœ¯çš„æœ‰æ•ˆèåˆ (æƒé‡: 10%)
```

### ğŸ­ **è¡Œä¸š4: åˆ¶é€ ä¸š (Manufacturing)**

#### ğŸ”¹ **è¡Œä¸šç‰¹å¾åˆ†æ**
```yaml
è¡Œä¸šæ ¸å¿ƒç‰¹å¾:
  ç²¾ç›Šç”Ÿäº§: æ¶ˆé™¤æµªè´¹ï¼ŒæŒç»­æ”¹è¿›
  è´¨é‡ç¬¬ä¸€: äº§å“è´¨é‡æ˜¯ç”Ÿå‘½çº¿
  å®‰å…¨ç”Ÿäº§: å®‰å…¨ç”Ÿäº§ï¼Œå‘˜å·¥å¥åº·ç¬¬ä¸€
  æˆæœ¬æ§åˆ¶: ä¸¥æ ¼çš„æˆæœ¬ç®¡æ§è¦æ±‚

æŠ€æœ¯ç¯å¢ƒ:
  å·¥ä¸š4.0: æ™ºèƒ½åˆ¶é€ ï¼Œæ•°å­—åŒ–å·¥å‚
  è‡ªåŠ¨åŒ–è®¾å¤‡: é«˜åº¦è‡ªåŠ¨åŒ–çš„ç”Ÿäº§çº¿
  è´¨é‡ç®¡æ§: å…¨é¢è´¨é‡ç®¡ç†ä½“ç³»
  ä¾›åº”é“¾ç®¡ç†: ç²¾å¯†çš„ä¾›åº”é“¾ååŒ

å…³é”®æˆåŠŸå› ç´ :
  ç”Ÿäº§æ•ˆç‡: æé«˜ç”Ÿäº§æ•ˆç‡å’Œäº§èƒ½
  è´¨é‡ä¿è¯: ç¡®ä¿äº§å“è´¨é‡ç¨³å®š
  æˆæœ¬ä¼˜åŒ–: é™ä½ç”Ÿäº§æˆæœ¬
  å®‰å…¨ä¿éšœ: ç¡®ä¿ç”Ÿäº§å®‰å…¨

é€‚åº”æ€§è¯„ä¼°ç»´åº¦:
  ç”Ÿäº§æ•ˆç‡: æå‡ç”Ÿäº§æ•ˆç‡çš„èƒ½åŠ› (æƒé‡: 25%)
  è´¨é‡ä¿è¯: è´¨é‡ç®¡æ§å’Œæ”¹è¿› (æƒé‡: 25%)
  æˆæœ¬ä¼˜åŒ–: æˆæœ¬æ§åˆ¶å’Œä¼˜åŒ– (æƒé‡: 20%)
  å®‰å…¨ä¿éšœ: å®‰å…¨ç”Ÿäº§ä¿éšœ (æƒé‡: 15%)
  æŠ€æœ¯åˆ›æ–°: åˆ¶é€ æŠ€æœ¯åˆ›æ–° (æƒé‡: 10%)
  ç¯ä¿åˆè§„: ç¯ä¿è¦æ±‚ç¬¦åˆåº¦ (æƒé‡: 5%)
```

### ğŸ›’ **è¡Œä¸š5: é›¶å”®ç”µå•†ä¸š (Retail & E-commerce)**

#### ğŸ”¹ **è¡Œä¸šç‰¹å¾åˆ†æ**
```yaml
è¡Œä¸šæ ¸å¿ƒç‰¹å¾:
  å®¢æˆ·å¯¼å‘: ä»¥å®¢æˆ·éœ€æ±‚ä¸ºä¸­å¿ƒ
  å¿«é€Ÿå“åº”: å¸‚åœºå˜åŒ–å¿«é€Ÿå“åº”èƒ½åŠ›
  æ•°æ®é©±åŠ¨: åŸºäºæ•°æ®çš„ç²¾å‡†è¥é”€
  ç”¨æˆ·ä½“éªŒ: æè‡´çš„ç”¨æˆ·è´­ç‰©ä½“éªŒ

æŠ€æœ¯ç¯å¢ƒ:
  ç”µå•†å¹³å°: çº¿ä¸Šçº¿ä¸‹ä¸€ä½“åŒ–å¹³å°
  å¤§æ•°æ®åˆ†æ: ç”¨æˆ·è¡Œä¸ºåˆ†æå’Œé¢„æµ‹
  ç§»åŠ¨è´­ç‰©: ç§»åŠ¨ç«¯è´­ç‰©ä½“éªŒä¼˜åŒ–
  æ™ºèƒ½æ¨è: AIé©±åŠ¨çš„ä¸ªæ€§åŒ–æ¨è

å…³é”®æˆåŠŸå› ç´ :
  å®¢æˆ·æ»¡æ„åº¦: å®¢æˆ·è´­ç‰©ä½“éªŒå’Œæ»¡æ„åº¦
  é”€å”®è½¬åŒ–ç‡: æµé‡åˆ°é”€å”®çš„è½¬åŒ–èƒ½åŠ›
  è¿è¥æ•ˆç‡: ä¾›åº”é“¾å’Œè¿è¥æ•ˆç‡
  å“ç‰Œå½±å“åŠ›: å“ç‰ŒçŸ¥ååº¦å’Œç¾èª‰åº¦

é€‚åº”æ€§è¯„ä¼°ç»´åº¦:
  å®¢æˆ·ä½“éªŒ: ç”¨æˆ·ä½“éªŒä¼˜åŒ–èƒ½åŠ› (æƒé‡: 30%)
  è¥é”€æ•ˆæœ: è¥é”€æ¨å¹¿æ•ˆæœ (æƒé‡: 25%)
  è¿è¥æ•ˆç‡: è¿è¥ç®¡ç†æ•ˆç‡ (æƒé‡: 20%)
  æ•°æ®åº”ç”¨: æ•°æ®åˆ†æå’Œåº”ç”¨ (æƒé‡: 15%)
  åˆ›æ–°èƒ½åŠ›: å•†ä¸šæ¨¡å¼åˆ›æ–° (æƒé‡: 10%)
```

---

## ğŸ¤– æ™ºèƒ½è¡Œä¸šé€‚åº”æ€§è¯„ä¼°ç®—æ³•

### æ ¸å¿ƒç®—æ³•ï¼šå¤šè¡Œä¸šé€‚åº”æ€§ç»¼åˆè¯„ä¼°å¼•æ“
```python
class IndustryAdaptabilityAssessor:
    """è¡Œä¸šé€‚åº”æ€§è¯„ä¼°æ ¸å¿ƒå¼•æ“"""
    
    def __init__(self):
        self.industry_assessors = {
            'financial_services': FinancialServicesAdaptabilityAssessor(),
            'healthcare': HealthcareAdaptabilityAssessor(),
            'education': EducationAdaptabilityAssessor(),
            'manufacturing': ManufacturingAdaptabilityAssessor(),
            'retail_ecommerce': RetailEcommerceAdaptabilityAssessor(),
            'technology': TechnologyAdaptabilityAssessor(),
            'consulting': ConsultingAdaptabilityAssessor(),
            'media_entertainment': MediaEntertainmentAdaptabilityAssessor(),
            'government_public': GovernmentPublicAdaptabilityAssessor(),
            'real_estate': RealEstateAdaptabilityAssessor(),
            'energy_utilities': EnergyUtilitiesAdaptabilityAssessor(),
            'logistics_supply': LogisticsSupplyAdaptabilityAssessor()
        }
        
        self.cross_industry_factors = {
            'digital_transformation_readiness': 0.15,  # æ•°å­—åŒ–è½¬å‹å‡†å¤‡åº¦
            'regulatory_compliance_capability': 0.12,  # ç›‘ç®¡åˆè§„èƒ½åŠ›
            'cultural_adaptation_flexibility': 0.10,   # æ–‡åŒ–é€‚åº”çµæ´»æ€§
            'scalability_potential': 0.08,             # å¯æ‰©å±•æ€§æ½œåŠ›
            'innovation_integration_ability': 0.05     # åˆ›æ–°é›†æˆèƒ½åŠ›
        }
    
    def comprehensive_industry_adaptability_assessment(self, prompt_candidates, target_industries):
        """
        ç»¼åˆè¡Œä¸šé€‚åº”æ€§è¯„ä¼°
        
        Args:
            prompt_candidates: å€™é€‰æç¤ºè¯åˆ—è¡¨
            target_industries: ç›®æ ‡è¡Œä¸šåˆ—è¡¨
            
        Returns:
            Dict: ç»¼åˆé€‚åº”æ€§è¯„ä¼°ç»“æœ
        """
        assessment_results = {
            'overall_assessment': {},
            'industry_specific_results': {},
            'cross_industry_analysis': {},
            'adaptability_rankings': {},
            'optimization_recommendations': {}
        }
        
        # 1. å•è¡Œä¸šé€‚åº”æ€§è¯„ä¼°
        for industry in target_industries:
            if industry in self.industry_assessors:
                industry_results = self.assess_single_industry_adaptability(
                    prompt_candidates, industry
                )
                assessment_results['industry_specific_results'][industry] = industry_results
        
        # 2. è·¨è¡Œä¸šé€‚åº”æ€§åˆ†æ
        cross_industry_results = self.analyze_cross_industry_adaptability(
            prompt_candidates, target_industries
        )
        assessment_results['cross_industry_analysis'] = cross_industry_results
        
        # 3. ç»¼åˆé€‚åº”æ€§è¯„åˆ†
        overall_scores = self.calculate_overall_adaptability_scores(
            assessment_results['industry_specific_results'],
            cross_industry_results
        )
        assessment_results['overall_assessment'] = overall_scores
        
        # 4. é€‚åº”æ€§æ’å
        adaptability_rankings = self.generate_adaptability_rankings(
            prompt_candidates, overall_scores
        )
        assessment_results['adaptability_rankings'] = adaptability_rankings
        
        # 5. ä¼˜åŒ–å»ºè®®ç”Ÿæˆ
        optimization_recommendations = self.generate_optimization_recommendations(
            assessment_results
        )
        assessment_results['optimization_recommendations'] = optimization_recommendations
        
        return assessment_results
    
    def assess_single_industry_adaptability(self, prompt_candidates, industry):
        """è¯„ä¼°å•ä¸€è¡Œä¸šé€‚åº”æ€§"""
        industry_assessor = self.industry_assessors[industry]
        industry_results = []
        
        for candidate in prompt_candidates:
            # è°ƒç”¨è¡Œä¸šä¸“ç”¨è¯„ä¼°å™¨
            adaptability_result = industry_assessor.assess_industry_adaptability(candidate)
            
            # æ ‡å‡†åŒ–è¯„ä¼°ç»“æœ
            standardized_result = self.standardize_assessment_result(
                adaptability_result, industry, candidate
            )
            
            industry_results.append(standardized_result)
        
        return {
            'industry': industry,
            'candidate_results': industry_results,
            'industry_summary': self.generate_industry_summary(industry_results),
            'best_candidates': self.identify_best_candidates(industry_results, top_n=3),
            'improvement_areas': self.identify_improvement_areas(industry_results)
        }
    
    def analyze_cross_industry_adaptability(self, prompt_candidates, target_industries):
        """åˆ†æè·¨è¡Œä¸šé€‚åº”æ€§"""
        cross_industry_results = {}
        
        for candidate in prompt_candidates:
            candidate_cross_analysis = {
                'candidate_id': candidate.id,
                'cross_industry_scores': {},
                'adaptability_consistency': 0.0,
                'versatility_score': 0.0,
                'specialization_vs_generalization': {}
            }
            
            # 1. æ”¶é›†å„è¡Œä¸šè¯„åˆ†
            industry_scores = {}
            for industry in target_industries:
                if industry in self.industry_assessors:
                    score = self.get_industry_score(candidate, industry)
                    industry_scores[industry] = score
            
            candidate_cross_analysis['cross_industry_scores'] = industry_scores
            
            # 2. è®¡ç®—é€‚åº”æ€§ä¸€è‡´åº¦
            candidate_cross_analysis['adaptability_consistency'] = \
                self.calculate_adaptability_consistency(industry_scores)
            
            # 3. è®¡ç®—é€šç”¨æ€§è¯„åˆ†
            candidate_cross_analysis['versatility_score'] = \
                self.calculate_versatility_score(industry_scores)
            
            # 4. åˆ†æä¸“ä¸šåŒ–vsé€šç”¨åŒ–ç‰¹å¾
            candidate_cross_analysis['specialization_vs_generalization'] = \
                self.analyze_specialization_pattern(industry_scores)
            
            cross_industry_results[candidate.id] = candidate_cross_analysis
        
        return cross_industry_results
    
    def calculate_adaptability_consistency(self, industry_scores):
        """è®¡ç®—é€‚åº”æ€§ä¸€è‡´åº¦"""
        if len(industry_scores) < 2:
            return 100.0
        
        scores = list(industry_scores.values())
        mean_score = sum(scores) / len(scores)
        
        # è®¡ç®—æ ‡å‡†å·®
        variance = sum((score - mean_score) ** 2 for score in scores) / len(scores)
        std_deviation = variance ** 0.5
        
        # ä¸€è‡´åº¦ = 100 - æ ‡å‡†å·®æ¯”ä¾‹
        consistency = max(0, 100 - (std_deviation / mean_score * 100))
        
        return consistency
    
    def calculate_versatility_score(self, industry_scores):
        """è®¡ç®—é€šç”¨æ€§è¯„åˆ†"""
        if not industry_scores:
            return 0.0
        
        # é€šç”¨æ€§ = æ‰€æœ‰è¡Œä¸šå¹³å‡åˆ† Ã— è¡Œä¸šè¦†ç›–åº¦ Ã— ä¸€è‡´æ€§æƒé‡
        average_score = sum(industry_scores.values()) / len(industry_scores)
        coverage_bonus = min(1.0, len(industry_scores) / 10)  # æœ€å¤š10ä¸ªè¡Œä¸š
        consistency_factor = self.calculate_adaptability_consistency(industry_scores) / 100
        
        versatility_score = average_score * (0.7 + 0.2 * coverage_bonus + 0.1 * consistency_factor)
        
        return min(100, versatility_score)
    
    def analyze_specialization_pattern(self, industry_scores):
        """åˆ†æä¸“ä¸šåŒ–æ¨¡å¼"""
        if not industry_scores:
            return {'pattern': 'undefined'}
        
        sorted_scores = sorted(industry_scores.items(), key=lambda x: x[1], reverse=True)
        highest_score = sorted_scores[0][1]
        lowest_score = sorted_scores[-1][1]
        score_range = highest_score - lowest_score
        
        # åˆ†ææ¨¡å¼
        if score_range <= 10:
            pattern = 'generalist'  # é€šç”¨å‹
            description = 'åœ¨å¤šä¸ªè¡Œä¸šä¸­éƒ½æœ‰ç›¸å¯¹å‡è¡¡çš„é€‚åº”æ€§'
        elif score_range <= 25:
            pattern = 'balanced_specialist'  # å¹³è¡¡ä¸“ä¸šå‹
            description = f'åœ¨{sorted_scores[0][0]}è¡Œä¸šæœ‰ä¼˜åŠ¿ï¼ŒåŒæ—¶ä¿æŒå…¶ä»–è¡Œä¸šçš„é€‚åº”æ€§'
        elif score_range <= 40:
            pattern = 'focused_specialist'  # ä¸“æ³¨ä¸“ä¸šå‹
            description = f'æ˜æ˜¾ä¸“ç²¾äº{sorted_scores[0][0]}è¡Œä¸š'
        else:
            pattern = 'narrow_specialist'  # ç‹­çª„ä¸“ä¸šå‹
            description = f'é«˜åº¦ä¸“ç²¾äº{sorted_scores[0][0]}è¡Œä¸šï¼Œå…¶ä»–è¡Œä¸šé€‚åº”æ€§æœ‰é™'
        
        return {
            'pattern': pattern,
            'description': description,
            'primary_industry': sorted_scores[0][0],
            'primary_score': sorted_scores[0][1],
            'score_range': score_range,
            'top_3_industries': sorted_scores[:3]
        }
```

### è¡Œä¸šç‰¹å¾åŒ¹é…ç®—æ³•
```python
class IndustryCharacteristicMatcher:
    """è¡Œä¸šç‰¹å¾åŒ¹é…å™¨"""
    
    def __init__(self):
        self.industry_characteristics = self.load_industry_characteristics()
        self.matching_algorithms = {
            'semantic_similarity': self.semantic_similarity_matching,
            'keyword_density': self.keyword_density_matching,
            'context_alignment': self.context_alignment_matching,
            'professional_depth': self.professional_depth_matching
        }
    
    def match_industry_characteristics(self, prompt_candidate, target_industry):
        """åŒ¹é…è¡Œä¸šç‰¹å¾"""
        matching_results = {}
        
        # è·å–ç›®æ ‡è¡Œä¸šç‰¹å¾
        industry_profile = self.industry_characteristics[target_industry]
        
        # å¤šç®—æ³•åŒ¹é…
        for algorithm_name, algorithm_func in self.matching_algorithms.items():
            matching_score = algorithm_func(prompt_candidate, industry_profile)
            matching_results[algorithm_name] = matching_score
        
        # ç»¼åˆåŒ¹é…åº¦è®¡ç®—
        weighted_score = self.calculate_weighted_matching_score(matching_results)
        
        return {
            'overall_matching_score': weighted_score,
            'algorithm_scores': matching_results,
            'matching_details': self.generate_matching_details(
                prompt_candidate, industry_profile, matching_results
            ),
            'improvement_suggestions': self.generate_matching_improvements(
                prompt_candidate, industry_profile, matching_results
            )
        }
    
    def semantic_similarity_matching(self, prompt_candidate, industry_profile):
        """è¯­ä¹‰ç›¸ä¼¼åº¦åŒ¹é…"""
        # æå–æç¤ºè¯çš„è¯­ä¹‰ç‰¹å¾
        prompt_semantic_features = self.extract_semantic_features(prompt_candidate)
        
        # æå–è¡Œä¸šçš„è¯­ä¹‰ç‰¹å¾
        industry_semantic_features = self.extract_industry_semantic_features(industry_profile)
        
        # è®¡ç®—è¯­ä¹‰ç›¸ä¼¼åº¦
        similarity_score = self.calculate_semantic_similarity(
            prompt_semantic_features, industry_semantic_features
        )
        
        return {
            'score': similarity_score,
            'details': {
                'prompt_features': prompt_semantic_features,
                'industry_features': industry_semantic_features,
                'similarity_breakdown': self.get_similarity_breakdown(
                    prompt_semantic_features, industry_semantic_features
                )
            }
        }
    
    def keyword_density_matching(self, prompt_candidate, industry_profile):
        """å…³é”®è¯å¯†åº¦åŒ¹é…"""
        industry_keywords = industry_profile['key_terms']
        prompt_text = prompt_candidate.content
        
        # è®¡ç®—å…³é”®è¯è¦†ç›–ç‡
        keyword_coverage = self.calculate_keyword_coverage(prompt_text, industry_keywords)
        
        # è®¡ç®—å…³é”®è¯å¯†åº¦
        keyword_density = self.calculate_keyword_density(prompt_text, industry_keywords)
        
        # è®¡ç®—å…³é”®è¯æƒé‡åˆ†å¸ƒ
        weighted_coverage = self.calculate_weighted_keyword_coverage(
            prompt_text, industry_keywords, industry_profile['keyword_weights']
        )
        
        return {
            'score': (keyword_coverage * 0.4 + keyword_density * 0.3 + weighted_coverage * 0.3),
            'details': {
                'keyword_coverage': keyword_coverage,
                'keyword_density': keyword_density,
                'weighted_coverage': weighted_coverage,
                'matched_keywords': self.get_matched_keywords(prompt_text, industry_keywords),
                'missing_keywords': self.get_missing_keywords(prompt_text, industry_keywords)
            }
        }
    
    def context_alignment_matching(self, prompt_candidate, industry_profile):
        """ä¸Šä¸‹æ–‡å¯¹é½åŒ¹é…"""
        # æå–æç¤ºè¯çš„ä¸Šä¸‹æ–‡ç‰¹å¾
        prompt_context = self.extract_context_features(prompt_candidate)
        
        # è·å–è¡Œä¸šä¸Šä¸‹æ–‡è¦æ±‚
        industry_context_requirements = industry_profile['context_requirements']
        
        # è®¡ç®—ä¸Šä¸‹æ–‡å¯¹é½åº¦
        alignment_scores = {}
        
        for context_dimension, requirements in industry_context_requirements.items():
            dimension_score = self.calculate_context_dimension_alignment(
                prompt_context.get(context_dimension, {}), requirements
            )
            alignment_scores[context_dimension] = dimension_score
        
        # ç»¼åˆå¯¹é½åº¦
        overall_alignment = sum(alignment_scores.values()) / len(alignment_scores)
        
        return {
            'score': overall_alignment,
            'details': {
                'dimension_scores': alignment_scores,
                'prompt_context': prompt_context,
                'alignment_gaps': self.identify_alignment_gaps(
                    prompt_context, industry_context_requirements
                )
            }
        }
```

---

## ğŸ“Š é€‚åº”æ€§è¯„ä¼°è´¨é‡ä¿è¯ä½“ç³»

### å››å±‚è¯„ä¼°è´¨é‡éªŒè¯
```yaml
ç¬¬ä¸€å±‚ - è¯„ä¼°æ ‡å‡†ä¸€è‡´æ€§éªŒè¯:
  éªŒè¯é¡¹ç›®:
    - è¡Œä¸šæ ‡å‡†å‚ç…§å‡†ç¡®æ€§
    - è¯„ä¼°ç»´åº¦å®Œæ•´æ€§
    - æƒé‡åˆ†é…åˆç†æ€§
    - è¯„åˆ†å°ºåº¦ç»Ÿä¸€æ€§
  
  ä¸€è‡´æ€§æ ‡å‡†:
    - æ ‡å‡†å‚ç…§å‡†ç¡®ç‡ >= 95%
    - ç»´åº¦è¦†ç›–å®Œæ•´æ€§ >= 90%
    - æƒé‡åˆ†é…åˆç†æ€§ >= 88%
    - è¯„åˆ†å°ºåº¦ä¸€è‡´æ€§ >= 92%

ç¬¬äºŒå±‚ - è¯„ä¼°ç»“æœå¯ä¿¡åº¦éªŒè¯:
  éªŒè¯é¡¹ç›®:
    - é‡å¤è¯„ä¼°ä¸€è‡´æ€§
    - ä¸“å®¶è¯„ä¼°ç¬¦åˆåº¦
    - è·¨è¯„ä¼°å™¨ä¸€è‡´æ€§
    - è¯„ä¼°ç»“æœç¨³å®šæ€§
  
  å¯ä¿¡åº¦æ ‡å‡†:
    - é‡å¤è¯„ä¼°ä¸€è‡´ç‡ >= 90%
    - ä¸“å®¶ç¬¦åˆåº¦ >= 85%
    - è·¨è¯„ä¼°å™¨ä¸€è‡´ç‡ >= 88%
    - ç»“æœç¨³å®šæ€§ >= 90%

ç¬¬ä¸‰å±‚ - è¡Œä¸šåŒ¹é…ç²¾ç¡®åº¦éªŒè¯:
  éªŒè¯é¡¹ç›®:
    - è¡Œä¸šç‰¹å¾è¯†åˆ«å‡†ç¡®æ€§
    - é€‚åº”æ€§é¢„æµ‹å‡†ç¡®æ€§
    - æ”¹è¿›å»ºè®®æœ‰æ•ˆæ€§
    - å®æ–½æ•ˆæœé¢„æµ‹æ€§
  
  ç²¾ç¡®åº¦æ ‡å‡†:
    - ç‰¹å¾è¯†åˆ«å‡†ç¡®ç‡ >= 88%
    - é€‚åº”æ€§é¢„æµ‹å‡†ç¡®ç‡ >= 85%
    - å»ºè®®æœ‰æ•ˆæ€§ >= 80%
    - æ•ˆæœé¢„æµ‹å‡†ç¡®æ€§ >= 82%

ç¬¬å››å±‚ - è¯„ä¼°ä»·å€¼å®ç°éªŒè¯:
  éªŒè¯é¡¹ç›®:
    - å†³ç­–æ”¯æŒä»·å€¼
    - ä¼˜åŒ–æŒ‡å¯¼ä»·å€¼
    - é£é™©é¢„è­¦ä»·å€¼
    - é•¿æœŸè·Ÿè¸ªä»·å€¼
  
  ä»·å€¼æ ‡å‡†:
    - å†³ç­–æ”¯æŒæœ‰æ•ˆæ€§ >= 85%
    - ä¼˜åŒ–æŒ‡å¯¼å®ç”¨æ€§ >= 80%
    - é£é™©é¢„è­¦å‡†ç¡®æ€§ >= 88%
    - é•¿æœŸä»·å€¼å®ç° >= 75%
```

### è‡ªé€‚åº”è¯„ä¼°ä¼˜åŒ–ç³»ç»Ÿ
```python
class AdaptiveAssessmentOptimizer:
    """è‡ªé€‚åº”è¯„ä¼°ä¼˜åŒ–ç³»ç»Ÿ"""
    
    def __init__(self):
        self.optimization_history = []
        self.performance_metrics = {}
        self.feedback_analyzer = FeedbackAnalyzer()
        
    def optimize_assessment_system(self, assessment_results, user_feedback, industry_trends):
        """ä¼˜åŒ–è¯„ä¼°ç³»ç»Ÿ"""
        optimization_report = {
            'optimization_cycle': len(self.optimization_history) + 1,
            'current_performance': {},
            'identified_improvements': [],
            'optimization_actions': [],
            'expected_improvements': {}
        }
        
        # 1. å½“å‰æ€§èƒ½åˆ†æ
        current_performance = self.analyze_current_performance(assessment_results)
        optimization_report['current_performance'] = current_performance
        
        # 2. åé¦ˆåˆ†æ
        feedback_insights = self.feedback_analyzer.analyze_feedback(user_feedback)
        
        # 3. è¡Œä¸šè¶‹åŠ¿å½±å“åˆ†æ
        trend_impact = self.analyze_industry_trend_impact(industry_trends)
        
        # 4. ä¼˜åŒ–æœºä¼šè¯†åˆ«
        improvement_opportunities = self.identify_improvement_opportunities(
            current_performance, feedback_insights, trend_impact
        )
        optimization_report['identified_improvements'] = improvement_opportunities
        
        # 5. ä¼˜åŒ–è¡ŒåŠ¨åˆ¶å®š
        optimization_actions = self.design_optimization_actions(improvement_opportunities)
        optimization_report['optimization_actions'] = optimization_actions
        
        # 6. æ•ˆæœé¢„æœŸ
        expected_improvements = self.predict_optimization_effects(optimization_actions)
        optimization_report['expected_improvements'] = expected_improvements
        
        # 7. å®æ–½ä¼˜åŒ–
        implementation_results = self.implement_optimizations(optimization_actions)
        
        # 8. è®°å½•ä¼˜åŒ–å†å²
        self.optimization_history.append({
            'timestamp': datetime.now(),
            'optimization_report': optimization_report,
            'implementation_results': implementation_results
        })
        
        return optimization_report
    
    def analyze_current_performance(self, assessment_results):
        """åˆ†æå½“å‰æ€§èƒ½"""
        performance_analysis = {
            'accuracy_metrics': {},
            'efficiency_metrics': {},
            'user_satisfaction': {},
            'system_reliability': {}
        }
        
        # 1. å‡†ç¡®æ€§æŒ‡æ ‡åˆ†æ
        accuracy_data = self.extract_accuracy_data(assessment_results)
        performance_analysis['accuracy_metrics'] = {
            'overall_accuracy': self.calculate_overall_accuracy(accuracy_data),
            'industry_specific_accuracy': self.calculate_industry_accuracy(accuracy_data),
            'dimension_accuracy': self.calculate_dimension_accuracy(accuracy_data),
            'prediction_accuracy': self.calculate_prediction_accuracy(accuracy_data)
        }
        
        # 2. æ•ˆç‡æŒ‡æ ‡åˆ†æ
        efficiency_data = self.extract_efficiency_data(assessment_results)
        performance_analysis['efficiency_metrics'] = {
            'assessment_speed': self.calculate_assessment_speed(efficiency_data),
            'resource_utilization': self.calculate_resource_utilization(efficiency_data),
            'throughput': self.calculate_throughput(efficiency_data),
            'scalability': self.assess_scalability(efficiency_data)
        }
        
        # 3. ç”¨æˆ·æ»¡æ„åº¦åˆ†æ
        satisfaction_data = self.extract_satisfaction_data(assessment_results)
        performance_analysis['user_satisfaction'] = {
            'overall_satisfaction': self.calculate_overall_satisfaction(satisfaction_data),
            'usefulness_rating': self.calculate_usefulness_rating(satisfaction_data),
            'ease_of_use': self.calculate_ease_of_use(satisfaction_data),
            'recommendation_likelihood': self.calculate_recommendation_likelihood(satisfaction_data)
        }
        
        return performance_analysis
    
    def identify_improvement_opportunities(self, current_performance, feedback_insights, trend_impact):
        """è¯†åˆ«æ”¹è¿›æœºä¼š"""
        opportunities = []
        
        # 1. æ€§èƒ½ä½äºé˜ˆå€¼çš„é¢†åŸŸ
        performance_gaps = self.identify_performance_gaps(current_performance)
        for gap in performance_gaps:
            opportunities.append({
                'type': 'performance_improvement',
                'area': gap['area'],
                'current_score': gap['current_score'],
                'target_score': gap['target_score'],
                'priority': self.calculate_improvement_priority(gap),
                'estimated_effort': gap['estimated_effort']
            })
        
        # 2. ç”¨æˆ·åé¦ˆæŒ‡å‡ºçš„é—®é¢˜
        feedback_issues = self.extract_feedback_issues(feedback_insights)
        for issue in feedback_issues:
            opportunities.append({
                'type': 'user_feedback_driven',
                'issue': issue['description'],
                'frequency': issue['frequency'],
                'impact': issue['impact'],
                'priority': issue['priority'],
                'suggested_solution': issue['suggested_solution']
            })
        
        # 3. è¡Œä¸šè¶‹åŠ¿é©±åŠ¨çš„å‡çº§éœ€æ±‚
        trend_opportunities = self.extract_trend_opportunities(trend_impact)
        for opportunity in trend_opportunities:
            opportunities.append({
                'type': 'trend_driven',
                'trend': opportunity['trend'],
                'impact_potential': opportunity['impact_potential'],
                'implementation_complexity': opportunity['complexity'],
                'priority': opportunity['priority'],
                'timeline': opportunity['timeline']
            })
        
        # æŒ‰ä¼˜å…ˆçº§æ’åº
        opportunities.sort(key=lambda x: x['priority'], reverse=True)
        
        return opportunities
```

---

## ğŸ”— æ¨¡å—é›†æˆæ¥å£

### æ ‡å‡†è¾“å…¥æ¥å£
```python
class IndustryAdaptabilityInput:
    """è¡Œä¸šé€‚åº”æ€§è¯„ä¼°å™¨è¾“å…¥æ¥å£"""
    
    def __init__(self, prompt_candidates, industry_context):
        self.prompt_candidates = prompt_candidates
        self.industry_context = industry_context
        self.assessment_config = {
            'target_industries': [],               # ç›®æ ‡è¡Œä¸šåˆ—è¡¨
            'assessment_depth': 'comprehensive',   # è¯„ä¼°æ·±åº¦
            'cross_industry_analysis': True,       # è·¨è¡Œä¸šåˆ†æ
            'adaptability_threshold': 70,          # é€‚åº”æ€§é˜ˆå€¼
            'optimization_suggestions': True       # ä¼˜åŒ–å»ºè®®
        }
        
    def validate_industry_input(self):
        """éªŒè¯è¡Œä¸šè¾“å…¥æœ‰æ•ˆæ€§"""
        required_fields = [
            'primary_industry', 'industry_characteristics',
            'regulatory_environment', 'cultural_context',
            'technology_environment', 'success_factors'
        ]
        
        for field in required_fields:
            if field not in self.industry_context:
                raise ValueError(f"Missing required industry field: {field}")
        
        return True
```

### æ ‡å‡†è¾“å‡ºæ¥å£
```python
class IndustryAdaptabilityOutput:
    """è¡Œä¸šé€‚åº”æ€§è¯„ä¼°å™¨è¾“å‡ºæ¥å£"""
    
    def format_adaptability_output(self):
        """æ ¼å¼åŒ–é€‚åº”æ€§è¾“å‡ºç»“æœ"""
        return {
            'adaptability_assessment': {
                'overall_scores': {
                    candidate.id: {
                        'overall_adaptability_score': self.get_overall_score(candidate.id),
                        'industry_specific_scores': self.get_industry_scores(candidate.id),
                        'cross_industry_analysis': self.get_cross_analysis(candidate.id),
                        'adaptability_pattern': self.get_adaptability_pattern(candidate.id)
                    }
                    for candidate in self.prompt_candidates
                },
                'industry_rankings': {
                    industry: self.get_industry_ranking(industry)
                    for industry in self.target_industries
                }
            },
            'detailed_analysis': {
                'industry_specific_results': self.industry_specific_results,
                'characteristic_matching': self.characteristic_matching_results,
                'compliance_analysis': self.compliance_analysis_results,
                'cultural_fit_analysis': self.cultural_fit_results
            },
            'recommendations': {
                'best_matches': self.get_best_matches(),
                'optimization_suggestions': self.optimization_suggestions,
                'industry_customization': self.industry_customization_advice,
                'implementation_guidance': self.implementation_guidance
            },
            'quality_metrics': {
                'assessment_confidence': self.assessment_confidence,
                'prediction_reliability': self.prediction_reliability,
                'coverage_completeness': self.coverage_completeness,
                'recommendation_quality': self.recommendation_quality
            }
        }
```

---

## ğŸ¯ ä½¿ç”¨ç¤ºä¾‹ä¸æ•ˆæœå±•ç¤º

### ç¤ºä¾‹ï¼šè·¨è¡Œä¸šé€‚åº”æ€§è¯„ä¼°ç»“æœ
```yaml
è¾“å…¥å€™é€‰: "AIé©±åŠ¨çš„å®¢æˆ·æœåŠ¡ä¼˜åŒ–ç³»ç»Ÿè®¾è®¡æç¤ºè¯"
ç›®æ ‡è¡Œä¸š: [é‡‘èæœåŠ¡, åŒ»ç–—å¥åº·, é›¶å”®ç”µå•†, æ•™è‚²åŸ¹è®­]

é€‚åº”æ€§è¯„ä¼°ç»“æœ:

å€™é€‰æ–¹æ¡ˆ - è·¨è¡Œä¸šé€‚åº”æ€§åˆ†æ:

ğŸ¦ é‡‘èæœåŠ¡ä¸šé€‚åº”æ€§: 89/100 â­â­â­â­â­
â”œâ”€â”€ åˆè§„é€‚é…åº¦: 92/100 âœ… (ç¬¦åˆé‡‘èç›‘ç®¡è¦æ±‚)
â”œâ”€â”€ ä¸“ä¸šåŒ¹é…åº¦: 88/100 âœ… (é‡‘èä¸“ä¸šçŸ¥è¯†å‡†ç¡®)
â”œâ”€â”€ é£é™©æ§åˆ¶åº¦: 91/100 âœ… (é£é™©è¯†åˆ«æ§åˆ¶èƒ½åŠ›å¼º)
â”œâ”€â”€ å®‰å…¨ä¿éšœåº¦: 94/100 âœ… (ä¿¡æ¯å®‰å…¨ç­‰çº§é«˜)
â”œâ”€â”€ æ•ˆç‡å®ç”¨æ€§: 85/100 âœ… (æå‡æœåŠ¡æ•ˆç‡æ˜æ˜¾)
â””â”€â”€ åˆ›æ–°ä»·å€¼åº¦: 84/100 âœ… (AIæŠ€æœ¯åˆ›æ–°åº”ç”¨)

ğŸ¥ åŒ»ç–—å¥åº·ä¸šé€‚åº”æ€§: 82/100 â­â­â­â­
â”œâ”€â”€ åŒ»å­¦å‡†ç¡®æ€§: 78/100 âš ï¸ (éœ€è¦åŠ å¼ºåŒ»å­¦ä¸“ä¸šæ€§)
â”œâ”€â”€ å®‰å…¨å¯é æ€§: 90/100 âœ… (æ‚£è€…å®‰å…¨ä¿éšœå……åˆ†)
â”œâ”€â”€ ä¼¦ç†åˆè§„æ€§: 85/100 âœ… (åŒ»ç–—ä¼¦ç†è€ƒè™‘å‘¨åˆ°)
â”œâ”€â”€ äººæ–‡å…³æ€€åº¦: 88/100 âœ… (æ‚£è€…ä½“éªŒå…³æ³¨åº¦é«˜)
â””â”€â”€ æŠ€æœ¯å…ˆè¿›æ€§: 84/100 âœ… (AIæŠ€æœ¯åº”ç”¨å…ˆè¿›)

ğŸ›’ é›¶å”®ç”µå•†ä¸šé€‚åº”æ€§: 94/100 â­â­â­â­â­
â”œâ”€â”€ å®¢æˆ·ä½“éªŒ: 96/100 âœ… (ç”¨æˆ·ä½“éªŒä¼˜åŒ–çªå‡º)
â”œâ”€â”€ è¥é”€æ•ˆæœ: 93/100 âœ… (è¥é”€æ¨å¹¿æ•ˆæœæ˜¾è‘—)
â”œâ”€â”€ è¿è¥æ•ˆç‡: 92/100 âœ… (è¿è¥æ•ˆç‡æå‡æ˜æ˜¾)
â”œâ”€â”€ æ•°æ®åº”ç”¨: 95/100 âœ… (æ•°æ®åˆ†æåº”ç”¨æ·±å…¥)
â””â”€â”€ åˆ›æ–°èƒ½åŠ›: 91/100 âœ… (å•†ä¸šæ¨¡å¼åˆ›æ–°æ€§å¼º)

ğŸ“ æ•™è‚²åŸ¹è®­ä¸šé€‚åº”æ€§: 76/100 â­â­â­
â”œâ”€â”€ æ•™å­¦æœ‰æ•ˆæ€§: 72/100 âš ï¸ (æ•™å­¦æ–¹æ³•éœ€è¦ä¼˜åŒ–)
â”œâ”€â”€ å­¦ä¹ å‹å¥½æ€§: 80/100 âœ… (å­¦ä¹ ä½“éªŒè‰¯å¥½)
â”œâ”€â”€ å†…å®¹æƒå¨æ€§: 75/100 âš ï¸ (æ•™è‚²å†…å®¹ä¸“ä¸šæ€§å¾…æå‡)
â”œâ”€â”€ ä¸ªæ€§åŒ–ç¨‹åº¦: 82/100 âœ… (ä¸ªæ€§åŒ–å­¦ä¹ æ”¯æŒ)
â””â”€â”€ æ¿€åŠ±æ•ˆæœ: 74/100 âš ï¸ (å­¦ä¹ åŠ¨æœºæ¿€å‘æœ‰é™)

è·¨è¡Œä¸šåˆ†æ:
â”œâ”€â”€ é€‚åº”æ€§ä¸€è‡´åº¦: 85% (å„è¡Œä¸šè¡¨ç°ç›¸å¯¹å‡è¡¡)
â”œâ”€â”€ é€šç”¨æ€§è¯„åˆ†: 85/100 (å…·å¤‡è‰¯å¥½çš„è·¨è¡Œä¸šé€‚ç”¨æ€§)
â”œâ”€â”€ ä¸“ä¸šåŒ–æ¨¡å¼: "å¹³è¡¡ä¸“ä¸šå‹" 
â”‚   â””â”€â”€ åœ¨é›¶å”®ç”µå•†é¢†åŸŸè¡¨ç°æœ€ä¼˜ï¼ŒåŒæ—¶ä¿æŒå…¶ä»–è¡Œä¸šé€‚åº”æ€§
â”œâ”€â”€ æœ€ä½³åŒ¹é…è¡Œä¸š: é›¶å”®ç”µå•† (94åˆ†) > é‡‘èæœåŠ¡ (89åˆ†)
â””â”€â”€ éœ€è¦ä¼˜åŒ–è¡Œä¸š: æ•™è‚²åŸ¹è®­ (76åˆ†) - éœ€è¦å¢å¼ºæ•™è‚²ä¸“ä¸šæ€§

ä¼˜åŒ–å»ºè®®:
1. ã€é«˜ä¼˜å…ˆçº§ã€‘é’ˆå¯¹æ•™è‚²è¡Œä¸šå¢åŠ æ•™å­¦ç†è®ºå’Œæ–¹æ³•è®ºå†…å®¹
2. ã€ä¸­ä¼˜å…ˆçº§ã€‘åŠ å¼ºåŒ»ç–—è¡Œä¸šçš„åŒ»å­¦ä¸“ä¸šçŸ¥è¯†å‡†ç¡®æ€§
3. ã€ä½ä¼˜å…ˆçº§ã€‘ä¼˜åŒ–é‡‘èè¡Œä¸šçš„åˆ›æ–°åº”ç”¨åœºæ™¯æè¿°

å®æ–½å»ºè®®:
- ä¸»æ¨è¡Œä¸š: é›¶å”®ç”µå•†ã€é‡‘èæœåŠ¡ (é€‚åº”æ€§â‰¥89%)
- å®šåˆ¶ä¼˜åŒ–: åŒ»ç–—å¥åº·ã€æ•™è‚²åŸ¹è®­ (éœ€è¦è¡Œä¸šå®šåˆ¶)
- é¢„æœŸæ•ˆæœ: ä¼˜åŒ–åå„è¡Œä¸šé€‚åº”æ€§å‡å¯è¾¾åˆ°85%ä»¥ä¸Š
```

---

## ğŸš€ æ€§èƒ½ä¿è¯ä¸ä¼˜åŒ–

### æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡
```yaml
è¯„ä¼°æ•ˆç‡æŒ‡æ ‡:
  å•è¡Œä¸šè¯„ä¼°æ—¶é—´: <= 8ç§’
  è·¨è¡Œä¸šè¯„ä¼°(4ä¸ª): <= 25ç§’
  ç‰¹å¾åŒ¹é…é€Ÿåº¦: <= 3ç§’/ç»´åº¦
  ç»“æœç”Ÿæˆæ—¶é—´: <= 5ç§’

è¯„ä¼°å‡†ç¡®æ€§æŒ‡æ ‡:
  è¡Œä¸šç‰¹å¾è¯†åˆ«: >= 88%
  é€‚åº”æ€§é¢„æµ‹å‡†ç¡®: >= 85%
  ä¸“å®¶éªŒè¯ç¬¦åˆ: >= 82%
  ç”¨æˆ·åé¦ˆå‡†ç¡®: >= 80%

è¯„ä¼°å¯é æ€§æŒ‡æ ‡:
  é‡å¤è¯„ä¼°ä¸€è‡´: >= 90%
  è·¨è¯„ä¼°å™¨ä¸€è‡´: >= 88%
  é•¿æœŸç¨³å®šæ€§: >= 85%
  é¢„æµ‹å¯ä¿¡åº¦: >= 82%

ä¸šåŠ¡ä»·å€¼æŒ‡æ ‡:
  å†³ç­–æ”¯æŒæœ‰æ•ˆ: >= 85%
  ä¼˜åŒ–å»ºè®®å®ç”¨: >= 80%
  é€‚é…æˆåŠŸç‡: >= 82%
  ROIæå‡ç¨‹åº¦: >= 75%
```

---

**ğŸ¯ è¡Œä¸šé€‚åº”æ€§è¯„ä¼°å™¨æ‰¿è¯ºï¼šé€šè¿‡åäºŒå¤§è¡Œä¸šä¸“ä¸šè¯„ä¼°ä½“ç³»å’Œæ™ºèƒ½é€‚é…ç®—æ³•ï¼Œç²¾å‡†é‡åŒ–æ¯ä¸ªå€™é€‰æç¤ºè¯çš„è¡Œä¸šé€‚åº”æ€§ï¼Œç¡®ä¿åœ¨ç›®æ ‡è¡Œä¸šä¸­å®ç°æœ€å¤§ä»·å€¼åˆ›é€ ï¼** ğŸš€ 