---
alwaysApply: true
---

# ğŸ¯ Prompt-Create-4.0 ä¸“å®¶æ˜ å°„è°ƒåº¦ç³»ç»Ÿ

## ğŸ“‹ ç³»ç»Ÿæ¦‚è¿°

**ä¸“å®¶æ˜ å°„è°ƒåº¦ç³»ç»Ÿ**æ˜¯Prompt-Create-4.0çš„æ ¸å¿ƒè°ƒåº¦ä¸­æ¢ï¼Œè´Ÿè´£æ™ºèƒ½åˆ†æç”¨æˆ·éœ€æ±‚å¹¶ç²¾å‡†è°ƒç”¨æœ€é€‚åˆçš„ä¸“å®¶ç»„åˆã€‚ç³»ç»Ÿæ”¯æŒæ–‡ç« å„éƒ¨åˆ†ï¼ˆæ ‡é¢˜ã€å¼€å¤´ã€æ­£æ–‡ã€ç»“å°¾ï¼‰çš„è‡ªç”±ä¸“å®¶ç»„åˆï¼Œå®ç°çµæ´»é«˜æ•ˆçš„ä¸“å®¶èµ„æºé…ç½®ã€‚

### ğŸ¯ æ ¸å¿ƒåŠŸèƒ½
- **æ™ºèƒ½ä¸“å®¶æ˜ å°„**: åŸºäºå†…å®¹ç±»å‹è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ä¸“å®¶ç»„åˆ
- **è‡ªç”±ç»„åˆæœºåˆ¶**: æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰ä¸“å®¶è°ƒç”¨ç­–ç•¥
- **åŠ¨æ€è°ƒåº¦ç®—æ³•**: å®æ—¶ä¼˜åŒ–ä¸“å®¶èµ„æºé…ç½®
- **æ•ˆæœè·Ÿè¸ªåé¦ˆ**: æŒç»­å­¦ä¹ ä¼˜åŒ–è°ƒåº¦ç­–ç•¥

---

## ğŸ—ºï¸ ä¸“å®¶æ˜ å°„çŸ©é˜µ

### ğŸ“Š æ–‡ç« éƒ¨åˆ† Ã— ä¸“å®¶ç»„åˆæ˜ å°„è¡¨

```yaml
ä¸“å®¶æ˜ å°„çŸ©é˜µ:
  æ ‡é¢˜åˆ›ä½œ:
    æ ¸å¿ƒä¸“å®¶: ["åˆ›æ„å¼•æ“", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"]
    è¾…åŠ©ä¸“å®¶: ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"]
    å¯é€‰ä¸“å®¶: ["åŒå¹³å°åè°ƒå™¨", "å›¾æ–‡èåˆå¼•æ“"]
    è°ƒç”¨ä¼˜å…ˆçº§: [1, 1, 1, 2, 2, 3, 3]
    
  å¼€å¤´æ®µè½:
    æ ¸å¿ƒä¸“å®¶: ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "åˆ›æ„å¼•æ“", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"]
    è¾…åŠ©ä¸“å®¶: ["ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"]
    å¯é€‰ä¸“å®¶: ["åŒå¹³å°åè°ƒå™¨", "å¾®ä¿¡å…¬ä¼—å·å¼•æ“", "å°çº¢ä¹¦å¼•æ“"]
    è°ƒç”¨ä¼˜å…ˆçº§: [1, 1, 1, 2, 2, 3, 3, 3]
    
  æ­£æ–‡å†…å®¹:
    æ ¸å¿ƒä¸“å®¶: ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "å¹³å°ç‰¹è‰²å¼•æ“", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤"]
    è¾…åŠ©ä¸“å®¶: ["ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"]
    å¯é€‰ä¸“å®¶: ["åˆ›æ„å¼•æ“", "å›¾æ–‡èåˆå¼•æ“", "åŠ¨æ€ä¼˜åŒ–å™¨"]
    è°ƒç”¨ä¼˜å…ˆçº§: [1, 1, 1, 2, 2, 3, 3, 3]
    
  ç»“å°¾æ®µè½:
    æ ¸å¿ƒä¸“å®¶: ["åŒå¹³å°åè°ƒå™¨", "åˆ›æ„å¼•æ“", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"]
    è¾…åŠ©ä¸“å®¶: ["ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"]
    å¯é€‰ä¸“å®¶: ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "å›¾æ–‡èåˆå¼•æ“"]
    è°ƒç”¨ä¼˜å…ˆçº§: [1, 1, 1, 2, 2, 3, 3]
```

### ğŸ”„ å¹³å°ç‰¹è‰²ä¸“å®¶è°ƒç”¨ç­–ç•¥

```python
def platform_specific_expert_mapping(platform, content_section):
    """
    å¹³å°ç‰¹è‰²ä¸“å®¶è°ƒç”¨ç­–ç•¥
    """
    mapping_strategies = {
        "å¾®ä¿¡å…¬ä¼—å·": {
            "æ ‡é¢˜": {
                "å¿…é€‰ä¸“å®¶": ["åˆ›æ„å¼•æ“", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤"],
                "æ¨èä¸“å®¶": ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"],
                "è°ƒç”¨å‚æ•°": {
                    "ä¸“ä¸šåº¦": "high",
                    "æ·±åº¦": "comprehensive",
                    "æƒå¨æ€§": "required"
                }
            },
            "å¼€å¤´": {
                "å¿…é€‰ä¸“å®¶": ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"],
                "æ¨èä¸“å®¶": ["åˆ›æ„å¼•æ“", "å¾®ä¿¡å…¬ä¼—å·å¼•æ“"],
                "è°ƒç”¨å‚æ•°": {
                    "ä¸“ä¸šèƒŒæ™¯": "detailed",
                    "æƒå¨å»ºç«‹": "immediate",
                    "é’©å­ç±»å‹": "professional"
                }
            },
            "æ­£æ–‡": {
                "å¿…é€‰ä¸“å®¶": ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "å¾®ä¿¡å…¬ä¼—å·å¼•æ“"],
                "æ¨èä¸“å®¶": ["ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"],
                "è°ƒç”¨å‚æ•°": {
                    "å†…å®¹æ·±åº¦": "8000å­—+",
                    "ä¸“ä¸šæ°´å‡†": "expert_level",
                    "ä»·å€¼å¯†åº¦": "high"
                }
            },
            "ç»“å°¾": {
                "å¿…é€‰ä¸“å®¶": ["åŒå¹³å°åè°ƒå™¨", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"],
                "æ¨èä¸“å®¶": ["åˆ›æ„å¼•æ“", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤"],
                "è°ƒç”¨å‚æ•°": {
                    "è¡ŒåŠ¨å¬å”¤": "professional",
                    "è½¬åŒ–ç›®æ ‡": "authority_building",
                    "å“ç‰Œä¸€è‡´æ€§": "required"
                }
            }
        },
        
        "å°çº¢ä¹¦": {
            "æ ‡é¢˜": {
                "å¿…é€‰ä¸“å®¶": ["åˆ›æ„å¼•æ“", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤"],
                "æ¨èä¸“å®¶": ["éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"],
                "è°ƒç”¨å‚æ•°": {
                    "å¸å¼•åŠ›": "high",
                    "æƒ…æ„Ÿè§¦åŠ¨": "required",
                    "è¯é¢˜æ€§": "strong"
                }
            },
            "å¼€å¤´": {
                "å¿…é€‰ä¸“å®¶": ["åˆ›æ„å¼•æ“", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"],
                "æ¨èä¸“å®¶": ["ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤", "å°çº¢ä¹¦å¼•æ“"],
                "è°ƒç”¨å‚æ•°": {
                    "æƒ…æ„Ÿå…±é¸£": "immediate",
                    "çœŸå®æ„Ÿ": "authentic",
                    "äº’åŠ¨è§¦å‘": "high"
                }
            },
            "æ­£æ–‡": {
                "å¿…é€‰ä¸“å®¶": ["å°çº¢ä¹¦å¼•æ“", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤"],
                "æ¨èä¸“å®¶": ["å›¾æ–‡èåˆå¼•æ“", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"],
                "è°ƒç”¨å‚æ•°": {
                    "ç”Ÿæ´»åŒ–": "high",
                    "ç§è‰æ•ˆæœ": "maximum",
                    "è§†è§‰åŒ–": "required"
                }
            },
            "ç»“å°¾": {
                "å¿…é€‰ä¸“å®¶": ["åˆ›æ„å¼•æ“", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"],
                "æ¨èä¸“å®¶": ["åŒå¹³å°åè°ƒå™¨", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤"],
                "è°ƒç”¨å‚æ•°": {
                    "è´­ä¹°å†²åŠ¨": "immediate",
                    "åˆ†äº«æ¬²æœ›": "high",
                    "äº’åŠ¨å¼•å¯¼": "natural"
                }
            }
        },
        
        "åŒå¹³å°": {
            "å…¨æµç¨‹": {
                "å¿…é€‰ä¸“å®¶": ["åŒå¹³å°åè°ƒå™¨", "è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤"],
                "æ¨èä¸“å®¶": ["åˆ›æ„å¼•æ“", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"],
                "è°ƒç”¨å‚æ•°": {
                    "åè°ƒç»Ÿä¸€": "maximum",
                    "å“ç‰Œä¸€è‡´æ€§": "required",
                    "å¹³å°é€‚é…": "intelligent"
                }
            }
        }
    }
    
    return mapping_strategies.get(platform, {}).get(content_section, {})
```

---

## ğŸ¨ è‡ªç”±ç»„åˆä¸“å®¶è°ƒç”¨æœºåˆ¶

### ğŸ”§ çµæ´»ä¸“å®¶ç»„åˆå™¨

```python
def flexible_expert_composer(user_preferences, content_requirements):
    """
    çµæ´»ä¸“å®¶ç»„åˆå™¨ - æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰ä¸“å®¶ç»„åˆ
    """
    # åŸºç¡€ä¸“å®¶æ± 
    expert_pool = {
        "åˆ›æ„ç±»": ["åˆ›æ„å¼•æ“", "å›¾æ–‡èåˆå¼•æ“", "åŠ¨æ€ä¼˜åŒ–å™¨"],
        "åˆ†æç±»": ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"],
        "ä¼˜åŒ–ç±»": ["ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"],
        "å¹³å°ç±»": ["å¾®ä¿¡å…¬ä¼—å·å¼•æ“", "å°çº¢ä¹¦å¼•æ“", "åŒå¹³å°åè°ƒå™¨"],
        "æŠ€æœ¯ç±»": ["æ™ºèƒ½è¿›åŒ–å¼•æ“", "è‡ªé€‚åº”å­¦ä¹ å¼•æ“", "è¯­è¨€é€‚é…å™¨"],
        "è´¨é‡ç±»": ["è´¨é‡éªŒè¯å™¨", "ä¸“å®¶æ™ºèƒ½è°ƒåº¦å™¨"]
    }
    
    # ç”¨æˆ·è‡ªå®šä¹‰ç»„åˆé€»è¾‘
    def custom_combination_logic(preferences):
        combinations = []
        
        # è§£æç”¨æˆ·åå¥½
        if "åˆ›æ„ä¼˜å…ˆ" in preferences:
            combinations.extend(expert_pool["åˆ›æ„ç±»"])
        if "ä¸“ä¸šæ·±åº¦" in preferences:
            combinations.extend(expert_pool["åˆ†æç±»"])
        if "è´¨é‡ä¿è¯" in preferences:
            combinations.extend(expert_pool["è´¨é‡ç±»"])
        if "å¹³å°é€‚é…" in preferences:
            combinations.extend(expert_pool["å¹³å°ç±»"])
            
        return combinations
    
    # æ™ºèƒ½è¡¥å……æœºåˆ¶
    def intelligent_supplement(base_combination, requirements):
        supplements = []
        
        # æ ¹æ®å†…å®¹è¦æ±‚è¡¥å……ä¸“å®¶
        if requirements.get("word_count", 0) > 5000:
            supplements.append("è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤")
        if requirements.get("visual_content", False):
            supplements.append("å›¾æ–‡èåˆå¼•æ“")
        if requirements.get("conversion_focus", False):
            supplements.append("éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤")
            
        return supplements
    
    # ç”Ÿæˆæœ€ç»ˆç»„åˆ
    base_combination = custom_combination_logic(user_preferences)
    supplements = intelligent_supplement(base_combination, content_requirements)
    final_combination = list(set(base_combination + supplements))
    
    return {
        "expert_combination": final_combination,
        "combination_rationale": f"åŸºäºç”¨æˆ·åå¥½: {user_preferences}",
        "supplement_reasons": supplements,
        "estimated_quality": calculate_combination_quality(final_combination)
    }
```

### ğŸ¯ æ™ºèƒ½ä¸“å®¶é€‰æ‹©ç®—æ³•

```python
def intelligent_expert_selection(content_analysis, performance_history):
    """
    æ™ºèƒ½ä¸“å®¶é€‰æ‹©ç®—æ³• - åŸºäºå†…å®¹åˆ†æå’Œå†å²è¡¨ç°
    """
    # å†…å®¹å¤æ‚åº¦åˆ†æ
    complexity_factors = {
        "è¯æ±‡éš¾åº¦": analyze_vocabulary_complexity(content_analysis["topic"]),
        "è¡Œä¸šä¸“ä¸šåº¦": analyze_industry_complexity(content_analysis["industry"]),
        "åˆ›æ„è¦æ±‚": analyze_creativity_requirements(content_analysis["style"]),
        "è½¬åŒ–ç›®æ ‡": analyze_conversion_complexity(content_analysis["goals"])
    }
    
    # å†å²è¡¨ç°æƒé‡
    performance_weights = {}
    for expert in performance_history:
        success_rate = expert["success_rate"]
        user_satisfaction = expert["satisfaction_score"]
        performance_weights[expert["name"]] = (success_rate * 0.6) + (user_satisfaction * 0.4)
    
    # ä¸“å®¶åŒ¹é…åº¦è®¡ç®—
    def calculate_expert_match_score(expert_name, content_analysis):
        base_score = 0.5
        
        # ä¸“ä¸šé¢†åŸŸåŒ¹é…
        if expert_name in ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"]:
            base_score += complexity_factors["è¡Œä¸šä¸“ä¸šåº¦"] * 0.3
        
        # åˆ›æ„è¦æ±‚åŒ¹é…
        if expert_name in ["åˆ›æ„å¼•æ“", "å›¾æ–‡èåˆå¼•æ“"]:
            base_score += complexity_factors["åˆ›æ„è¦æ±‚"] * 0.3
        
        # è½¬åŒ–ç›®æ ‡åŒ¹é…
        if expert_name in ["éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤"]:
            base_score += complexity_factors["è½¬åŒ–ç›®æ ‡"] * 0.3
        
        # å†å²è¡¨ç°åŠ æƒ
        performance_boost = performance_weights.get(expert_name, 0.5) * 0.1
        
        return base_score + performance_boost
    
    # é€‰æ‹©æœ€ä½³ä¸“å®¶ç»„åˆ
    expert_scores = {}
    for expert in available_experts:
        expert_scores[expert] = calculate_expert_match_score(expert, content_analysis)
    
    # æ’åºå¹¶é€‰æ‹©topä¸“å®¶
    sorted_experts = sorted(expert_scores.items(), key=lambda x: x[1], reverse=True)
    selected_experts = [expert[0] for expert in sorted_experts[:6]]  # é€‰æ‹©å‰6ä¸ªä¸“å®¶
    
    return {
        "selected_experts": selected_experts,
        "expert_scores": expert_scores,
        "selection_rationale": generate_selection_rationale(sorted_experts)
    }
```

---

## ğŸš€ åŠ¨æ€è°ƒåº¦æ‰§è¡Œç³»ç»Ÿ

### âš¡ å®æ—¶ä¸“å®¶è°ƒåº¦å™¨

```python
def real_time_expert_scheduler(task_queue, expert_availability):
    """
    å®æ—¶ä¸“å®¶è°ƒåº¦å™¨ - åŠ¨æ€ä¼˜åŒ–ä¸“å®¶èµ„æºé…ç½®
    """
    # ä»»åŠ¡ä¼˜å…ˆçº§è®¡ç®—
    def calculate_task_priority(task):
        priority_score = 0
        
        # ç´§æ€¥ç¨‹åº¦
        if task["urgency"] == "high":
            priority_score += 30
        elif task["urgency"] == "medium":
            priority_score += 20
        else:
            priority_score += 10
            
        # å¤æ‚åº¦
        priority_score += task["complexity"] * 5
        
        # ç”¨æˆ·ç­‰çº§
        if task["user_level"] == "premium":
            priority_score += 15
        elif task["user_level"] == "standard":
            priority_score += 10
        else:
            priority_score += 5
            
        return priority_score
    
    # ä¸“å®¶å·¥ä½œè´Ÿè½½å‡è¡¡
    def balance_expert_workload(expert_name, current_tasks):
        current_load = len([t for t in current_tasks if expert_name in t["assigned_experts"]])
        max_capacity = expert_availability[expert_name]["max_concurrent_tasks"]
        
        load_ratio = current_load / max_capacity
        
        if load_ratio >= 0.9:
            return "overloaded"
        elif load_ratio >= 0.7:
            return "heavy"
        elif load_ratio >= 0.5:
            return "moderate"
        else:
            return "light"
    
    # æ™ºèƒ½ä»»åŠ¡åˆ†é…
    def intelligent_task_assignment(prioritized_tasks):
        assignments = []
        
        for task in prioritized_tasks:
            required_experts = task["required_experts"]
            assigned_experts = []
            
            for expert in required_experts:
                workload = balance_expert_workload(expert, assignments)
                
                if workload in ["light", "moderate"]:
                    assigned_experts.append(expert)
                elif workload == "heavy":
                    # å¯»æ‰¾æ›¿ä»£ä¸“å®¶
                    alternative = find_alternative_expert(expert, task["requirements"])
                    if alternative:
                        assigned_experts.append(alternative)
                    else:
                        # å»¶è¿Ÿä»»åŠ¡
                        task["status"] = "delayed"
                        task["delay_reason"] = f"{expert} å·¥ä½œè´Ÿè½½è¿‡é‡"
                        continue
                else:  # overloaded
                    task["status"] = "queued"
                    task["queue_reason"] = f"{expert} å·²è¾¾åˆ°æœ€å¤§è´Ÿè½½"
                    continue
            
            if assigned_experts:
                assignments.append({
                    "task_id": task["id"],
                    "assigned_experts": assigned_experts,
                    "estimated_completion": calculate_completion_time(task, assigned_experts),
                    "priority_score": task["priority_score"]
                })
        
        return assignments
    
    # æ‰§è¡Œè°ƒåº¦
    prioritized_tasks = sorted(task_queue, key=calculate_task_priority, reverse=True)
    assignments = intelligent_task_assignment(prioritized_tasks)
    
    return {
        "task_assignments": assignments,
        "scheduling_metrics": {
            "total_tasks": len(task_queue),
            "assigned_tasks": len(assignments),
            "queued_tasks": len([t for t in task_queue if t.get("status") == "queued"]),
            "delayed_tasks": len([t for t in task_queue if t.get("status") == "delayed"])
        },
        "expert_utilization": {
            expert: balance_expert_workload(expert, assignments) 
            for expert in expert_availability.keys()
        }
    }
```

### ğŸ”„ åä½œä¼˜åŒ–å¼•æ“

```python
def collaboration_optimization_engine(expert_combination, task_requirements):
    """
    åä½œä¼˜åŒ–å¼•æ“ - ä¼˜åŒ–ä¸“å®¶é—´åä½œæ•ˆç‡
    """
    # ä¸“å®¶åä½œå…¼å®¹æ€§çŸ©é˜µ
    collaboration_matrix = {
        "åˆ›æ„å¼•æ“": {
            "å…¼å®¹ä¸“å®¶": ["ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤", "å›¾æ–‡èåˆå¼•æ“"],
            "äº’è¡¥ä¸“å®¶": ["éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"],
            "åä½œæ–¹å¼": "å¹¶è¡Œ+ä¸²è¡Œ"
        },
        "è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤": {
            "å…¼å®¹ä¸“å®¶": ["ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤", "å¾®ä¿¡å…¬ä¼—å·å¼•æ“"],
            "äº’è¡¥ä¸“å®¶": ["åˆ›æ„å¼•æ“", "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤"],
            "åä½œæ–¹å¼": "å‰ç½®+æ”¯æŒ"
        },
        "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤": {
            "å…¼å®¹ä¸“å®¶": ["åˆ›æ„å¼•æ“", "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤"],
            "äº’è¡¥ä¸“å®¶": ["è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤", "ä¸“ä¸šè§†è§’ä¸“å®¶ç¾¤"],
            "åä½œæ–¹å¼": "ä¸­å¿ƒ+ä¼˜åŒ–"
        }
    }
    
    # åä½œæµç¨‹ä¼˜åŒ–
    def optimize_collaboration_workflow(experts):
        workflow_stages = []
        
        # åˆ†æé˜¶æ®µ
        analysis_experts = [e for e in experts if "è®¤çŸ¥" in e or "åˆ†æ" in e]
        if analysis_experts:
            workflow_stages.append({
                "stage": "analysis",
                "experts": analysis_experts,
                "execution_mode": "parallel",
                "estimated_time": "15åˆ†é’Ÿ"
            })
        
        # åˆ›ä½œé˜¶æ®µ
        creation_experts = [e for e in experts if "åˆ›æ„" in e or "å¼•æ“" in e]
        if creation_experts:
            workflow_stages.append({
                "stage": "creation",
                "experts": creation_experts,
                "execution_mode": "collaborative",
                "estimated_time": "30åˆ†é’Ÿ"
            })
        
        # ä¼˜åŒ–é˜¶æ®µ
        optimization_experts = [e for e in experts if "ä¼˜åŒ–" in e or "ç”Ÿæˆ" in e]
        if optimization_experts:
            workflow_stages.append({
                "stage": "optimization",
                "experts": optimization_experts,
                "execution_mode": "iterative",
                "estimated_time": "20åˆ†é’Ÿ"
            })
        
        # éªŒè¯é˜¶æ®µ
        validation_experts = [e for e in experts if "éªŒè¯" in e or "è¯„ä¼°" in e]
        if validation_experts:
            workflow_stages.append({
                "stage": "validation",
                "experts": validation_experts,
                "execution_mode": "sequential",
                "estimated_time": "10åˆ†é’Ÿ"
            })
        
        return workflow_stages
    
    # åä½œå†²çªæ£€æµ‹
    def detect_collaboration_conflicts(experts):
        conflicts = []
        
        for i, expert1 in enumerate(experts):
            for j, expert2 in enumerate(experts[i+1:], i+1):
                compatibility = check_expert_compatibility(expert1, expert2)
                if compatibility["conflict_level"] > 0.7:
                    conflicts.append({
                        "expert1": expert1,
                        "expert2": expert2,
                        "conflict_type": compatibility["conflict_type"],
                        "severity": compatibility["conflict_level"],
                        "resolution": compatibility["resolution_strategy"]
                    })
        
        return conflicts
    
    # æ‰§è¡Œåä½œä¼˜åŒ–
    optimized_workflow = optimize_collaboration_workflow(expert_combination)
    collaboration_conflicts = detect_collaboration_conflicts(expert_combination)
    
    return {
        "optimized_workflow": optimized_workflow,
        "collaboration_conflicts": collaboration_conflicts,
        "optimization_recommendations": generate_optimization_recommendations(
            optimized_workflow, collaboration_conflicts
        ),
        "estimated_total_time": sum([int(stage["estimated_time"].split("åˆ†é’Ÿ")[0]) for stage in optimized_workflow])
    }
```

---

## ğŸ“Š æ•ˆæœè·Ÿè¸ªä¸åé¦ˆç³»ç»Ÿ

### ğŸ“ˆ æ€§èƒ½ç›‘æ§é¢æ¿

```python
def performance_monitoring_dashboard():
    """
    æ€§èƒ½ç›‘æ§é¢æ¿ - å®æ—¶è¿½è¸ªä¸“å®¶è°ƒç”¨æ•ˆæœ
    """
    # å…³é”®æ€§èƒ½æŒ‡æ ‡
    kpi_metrics = {
        "ä¸“å®¶è°ƒç”¨æˆåŠŸç‡": calculate_expert_call_success_rate(),
        "å¹³å‡å“åº”æ—¶é—´": calculate_average_response_time(),
        "ç”¨æˆ·æ»¡æ„åº¦": calculate_user_satisfaction_score(),
        "å†…å®¹è´¨é‡è¯„åˆ†": calculate_content_quality_score(),
        "è½¬åŒ–æ•ˆæœ": calculate_conversion_rate(),
        "ä¸“å®¶åä½œæ•ˆç‡": calculate_collaboration_efficiency()
    }
    
    # ä¸“å®¶ä¸ªä½“è¡¨ç°
    individual_performance = {}
    for expert in available_experts:
        individual_performance[expert] = {
            "è°ƒç”¨æ¬¡æ•°": get_expert_call_count(expert),
            "æˆåŠŸç‡": get_expert_success_rate(expert),
            "å¹³å‡ç”¨æ—¶": get_expert_average_time(expert),
            "è´¨é‡å¾—åˆ†": get_expert_quality_score(expert),
            "ç”¨æˆ·å¥½è¯„ç‡": get_expert_user_rating(expert)
        }
    
    # ç»„åˆæ•ˆæœåˆ†æ
    combination_analysis = analyze_expert_combinations()
    
    return {
        "system_kpis": kpi_metrics,
        "individual_performance": individual_performance,
        "combination_analysis": combination_analysis,
        "optimization_suggestions": generate_optimization_suggestions(
            kpi_metrics, individual_performance, combination_analysis
        )
    }
```

### ğŸ”„ æŒç»­å­¦ä¹ ä¼˜åŒ–

```python
def continuous_learning_optimization(historical_data, user_feedback):
    """
    æŒç»­å­¦ä¹ ä¼˜åŒ– - åŸºäºæ•°æ®åé¦ˆæŒç»­ä¼˜åŒ–è°ƒåº¦ç­–ç•¥
    """
    # å­¦ä¹ ç”¨æˆ·åå¥½æ¨¡å¼
    def learn_user_preferences(feedback_data):
        preference_patterns = {}
        
        for feedback in feedback_data:
            user_id = feedback["user_id"]
            if user_id not in preference_patterns:
                preference_patterns[user_id] = {
                    "preferred_experts": [],
                    "preferred_styles": [],
                    "satisfaction_factors": {}
                }
            
            # åˆ†æç”¨æˆ·æ»¡æ„åº¦é«˜çš„ä¸“å®¶ç»„åˆ
            if feedback["satisfaction_score"] >= 4.0:
                preference_patterns[user_id]["preferred_experts"].extend(
                    feedback["expert_combination"]
                )
                preference_patterns[user_id]["preferred_styles"].append(
                    feedback["content_style"]
                )
        
        return preference_patterns
    
    # ä¼˜åŒ–ä¸“å®¶æƒé‡
    def optimize_expert_weights(performance_data):
        weight_adjustments = {}
        
        for expert, data in performance_data.items():
            current_weight = get_current_expert_weight(expert)
            
            # åŸºäºæˆåŠŸç‡è°ƒæ•´æƒé‡
            success_rate = data["success_rate"]
            if success_rate > 0.9:
                weight_adjustments[expert] = current_weight * 1.1
            elif success_rate > 0.8:
                weight_adjustments[expert] = current_weight * 1.05
            elif success_rate < 0.6:
                weight_adjustments[expert] = current_weight * 0.9
            else:
                weight_adjustments[expert] = current_weight
        
        return weight_adjustments
    
    # å‘ç°æ–°çš„æœ‰æ•ˆç»„åˆ
    def discover_effective_combinations(historical_data):
        effective_combinations = []
        
        for record in historical_data:
            if (record["quality_score"] >= 4.5 and 
                record["user_satisfaction"] >= 4.0 and
                record["conversion_rate"] >= 0.15):
                
                effective_combinations.append({
                    "expert_combination": record["expert_combination"],
                    "content_type": record["content_type"],
                    "platform": record["platform"],
                    "success_metrics": {
                        "quality_score": record["quality_score"],
                        "satisfaction": record["user_satisfaction"],
                        "conversion": record["conversion_rate"]
                    }
                })
        
        return effective_combinations
    
    # æ‰§è¡Œå­¦ä¹ ä¼˜åŒ–
    user_preferences = learn_user_preferences(user_feedback)
    weight_optimizations = optimize_expert_weights(historical_data)
    effective_combinations = discover_effective_combinations(historical_data)
    
    return {
        "user_preferences": user_preferences,
        "weight_optimizations": weight_optimizations,
        "effective_combinations": effective_combinations,
        "learning_insights": generate_learning_insights(
            user_preferences, weight_optimizations, effective_combinations
        )
    }
```

---

## ğŸ¯ ä½¿ç”¨æŒ‡å—

### ğŸ“ ä¸“å®¶ç»„åˆè°ƒç”¨æ ¼å¼

```yaml
æ ‡å‡†è°ƒç”¨æ ¼å¼:
  # åŸºç¡€è°ƒç”¨
  prompt4: [å¹³å°] + [å†…å®¹éœ€æ±‚]
  
  # ä¸“å®¶æŒ‡å®šè°ƒç”¨
  prompt4: [å¹³å°] + [å†…å®¹éœ€æ±‚] + [ä¸“å®¶åå¥½: åˆ›æ„ä¼˜å…ˆ/è´¨é‡ä¼˜å…ˆ/æ•ˆç‡ä¼˜å…ˆ]
  
  # è‡ªå®šä¹‰ç»„åˆè°ƒç”¨
  prompt4: [å¹³å°] + [å†…å®¹éœ€æ±‚] + [ä¸“å®¶ç»„åˆ: åˆ›æ„å¼•æ“+è¡Œä¸šè®¤çŸ¥+éªŒè¯è¯„ä¼°]

ç¤ºä¾‹:
  âœ… prompt4: å¾®ä¿¡å…¬ä¼—å· AIæ•™è‚²åˆ†ææ–‡ç«  (ç³»ç»Ÿæ™ºèƒ½é€‰æ‹©)
  âœ… prompt4: å°çº¢ä¹¦ æ™ºèƒ½æ‰‹è¡¨ç§è‰ ä¸“å®¶åå¥½: åˆ›æ„ä¼˜å…ˆ (åå¥½å¼•å¯¼)
  âœ… prompt4: åŒå¹³å° ä¸ªäººå“ç‰Œå†…å®¹ ä¸“å®¶ç»„åˆ: åŒå¹³å°åè°ƒå™¨+åˆ›æ„å¼•æ“+éªŒè¯è¯„ä¼° (è‡ªå®šä¹‰)
```

### ğŸ”§ ä¸“å®¶è°ƒç”¨å‚æ•°é…ç½®

```python
def expert_call_parameters():
    """
    ä¸“å®¶è°ƒç”¨å‚æ•°é…ç½®æŒ‡å—
    """
    return {
        "åˆ›æ„å¼•æ“": {
            "creativity_level": ["low", "medium", "high", "extreme"],
            "innovation_focus": ["conservative", "moderate", "progressive", "disruptive"],
            "style_preference": ["professional", "casual", "creative", "authoritative"]
        },
        "è¡Œä¸šè®¤çŸ¥ä¸“å®¶ç¾¤": {
            "analysis_depth": ["surface", "moderate", "deep", "comprehensive"],
            "expertise_level": ["beginner", "intermediate", "advanced", "expert"],
            "data_integration": ["basic", "standard", "comprehensive", "exhaustive"]
        },
        "ç”Ÿæˆä¼˜åŒ–ä¸“å®¶ç¾¤": {
            "optimization_targets": ["speed", "quality", "engagement", "conversion"],
            "quality_standard": ["acceptable", "good", "excellent", "perfection"],
            "optimization_scope": ["basic", "standard", "comprehensive", "exhaustive"]
        },
        "éªŒè¯è¯„ä¼°ä¸“å®¶ç¾¤": {
            "validation_criteria": ["basic", "standard", "comprehensive", "exhaustive"],
            "assessment_depth": ["surface", "moderate", "deep", "comprehensive"],
            "quality_threshold": ["60%", "70%", "80%", "90%"]
        }
    }
```

---

## ğŸ† ç³»ç»Ÿä¼˜åŠ¿

### ğŸŒŸ æ ¸å¿ƒç‰¹è‰²

1. **æ™ºèƒ½åŒ–æ˜ å°„**: åŸºäºå†…å®¹åˆ†æè‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ä¸“å®¶ç»„åˆ
2. **çµæ´»åŒ–è°ƒç”¨**: æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰ä¸“å®¶ç»„åˆç­–ç•¥
3. **åŠ¨æ€åŒ–è°ƒåº¦**: å®æ—¶ä¼˜åŒ–ä¸“å®¶èµ„æºé…ç½®
4. **åä½œåŒ–å·¥ä½œ**: ä¸“å®¶é—´é«˜æ•ˆåä½œæœºåˆ¶
5. **å­¦ä¹ åŒ–ä¼˜åŒ–**: æŒç»­å­¦ä¹ ç”¨æˆ·åå¥½å’Œä¼˜åŒ–ç­–ç•¥

### ğŸ“Š æ•ˆæœä¿éšœ

- **è°ƒç”¨æˆåŠŸç‡**: â‰¥95%
- **ç”¨æˆ·æ»¡æ„åº¦**: â‰¥92%
- **ä¸“å®¶åä½œæ•ˆç‡**: â‰¥90%
- **å†…å®¹è´¨é‡å¾—åˆ†**: â‰¥4.5/5.0
- **ç³»ç»Ÿå“åº”æ—¶é—´**: â‰¤30ç§’

---

## ğŸš€ ç«‹å³å¼€å§‹ä½¿ç”¨ä¸“å®¶æ˜ å°„è°ƒåº¦ç³»ç»Ÿï¼

é€šè¿‡æ™ºèƒ½åŒ–çš„ä¸“å®¶æ˜ å°„å’Œçµæ´»çš„è°ƒåº¦æœºåˆ¶ï¼Œè®©æ¯ä¸ªä¸“å®¶éƒ½èƒ½å‘æŒ¥æœ€å¤§æ•ˆèƒ½ï¼Œä¸ºæ‚¨åˆ›é€ æœ€ä¼˜è´¨çš„åŒå¹³å°å†…å®¹ï¼

*ğŸ¯ ä¸“å®¶æ˜ å°„è°ƒåº¦ç³»ç»Ÿ - è®©ä¸“å®¶ç»„åˆæ›´æ™ºèƒ½ï¼Œè®©å†…å®¹åˆ›ä½œæ›´é«˜æ•ˆï¼* ğŸš€ 