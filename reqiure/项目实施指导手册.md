# 🛠️ 20天Web3项目实施指导手册

## 🎯 项目总览

### 📊 三大核心项目规划
| 项目 | 时间 | 技术栈 | 核心功能 | 展示亮点 |
|------|------|--------|----------|----------|
| **DeFi数据聚合器** | Day 11-12 | Go+Gin+PostgreSQL+Redis | 实时DeFi数据收集分析 | 微服务架构+高并发 |
| **Web3交易监控** | Day 13-14 | Go+gRPC+MongoDB+WebSocket | 区块链交易实时监控 | 事件驱动+实时推送 |
| **NFT数据分析器** | Day 15 | Go+Fiber+GraphQL+TimescaleDB | NFT市场数据分析 | GraphQL API+时序数据 |

### 🏆 项目成功标准
```yaml
技术标准:
  - 代码质量: 符合Go最佳实践，单元测试覆盖率>80%
  - 架构设计: 清晰的分层架构，良好的模块化
  - 性能表现: API响应时间<100ms，支持并发1000+
  - 部署方式: Docker容器化，一键部署

业务标准:
  - 功能完整: 核心功能完全实现，边界情况处理
  - 数据准确: 与主流平台数据一致性>99%
  - 用户体验: 界面友好，操作流畅
  - 扩展性: 支持新功能快速添加

展示标准:
  - 文档完整: README、API文档、部署指南
  - 演示流畅: 5分钟完整功能演示
  - 技术深度: 能解释核心技术选型和难点
  - 商业理解: 展示对Web3业务的深度理解
```

---

## 🏗️ 项目1：DeFi数据聚合器 (Day 11-12)

### 📋 项目概述
**项目名称**: DeFi Protocol Data Aggregator
**核心价值**: 实时聚合主流DeFi协议数据，提供统一API访问
**技术亮点**: 微服务架构 + 高并发数据处理 + 智能缓存策略

### 🎯 功能需求详细定义
```yaml
核心功能模块:
  1. 数据收集服务:
     - 实时监听Uniswap/Sushiswap池子数据
     - 获取Compound/Aave借贷利率
     - 追踪TVL和交易量变化
     - 价格发现和套利机会识别

  2. 数据处理服务:
     - 数据清洗和标准化
     - 实时计算APY/APR
     - 风险评估和评分
     - 趋势分析和预测

  3. API网关服务:
     - RESTful API设计
     - 数据聚合和过滤
     - 访问控制和限流
     - 响应格式标准化

  4. 数据存储层:
     - 实时数据缓存(Redis)
     - 历史数据存储(PostgreSQL)
     - 数据备份和恢复
     - 查询性能优化
```

### 🏗️ 系统架构设计
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   数据收集服务   │    │   数据处理服务   │    │   API网关服务   │
│  (Collector)    │    │  (Processor)    │    │   (Gateway)     │
│                 │    │                 │    │                 │
│ • 区块链监听     │◄──►│ • 数据清洗       │◄──►│ • RESTful API   │
│ • 协议数据抓取   │    │ • 指标计算       │    │ • 响应聚合       │
│ • 实时价格更新   │    │ • 风险评估       │    │ • 访问控制       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
         ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
         │     Redis       │    │  PostgreSQL     │    │    WebSocket    │
         │   (缓存层)       │    │  (持久化层)      │    │   (实时推送)     │
         │                 │    │                 │    │                 │
         │ • 实时数据       │    │ • 历史数据       │    │ • 价格更新       │
         │ • 热点缓存       │    │ • 用户配置       │    │ • 异常告警       │
         └─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 💻 核心代码实现指南

#### Day 11 任务：基础架构搭建

**1. 项目结构设计**
```
defi-aggregator/
├── cmd/
│   ├── collector/           # 数据收集服务
│   ├── processor/           # 数据处理服务
│   └── gateway/             # API网关服务
├── internal/
│   ├── collector/
│   │   ├── ethereum/        # 以太坊数据收集
│   │   ├── uniswap/         # Uniswap协议
│   │   └── compound/        # Compound协议
│   ├── processor/
│   │   ├── calculator/      # 指标计算
│   │   ├── analyzer/        # 数据分析
│   │   └── risk/            # 风险评估
│   ├── gateway/
│   │   ├── handlers/        # HTTP处理器
│   │   ├── middleware/      # 中间件
│   │   └── websocket/       # WebSocket处理
│   ├── shared/
│   │   ├── models/          # 数据模型
│   │   ├── database/        # 数据库操作
│   │   ├── cache/           # 缓存操作
│   │   └── config/          # 配置管理
├── api/
│   └── openapi.yaml         # API规范
├── deployments/
│   ├── docker-compose.yml   # 本地部署
│   └── Dockerfile           # 容器构建
└── docs/
    ├── architecture.md      # 架构文档
    └── api.md               # API文档
```

**2. 基础模型定义**
```go
// internal/shared/models/defi.go
package models

import (
    "time"
    "github.com/shopspring/decimal"
)

// DeFi协议信息
type Protocol struct {
    ID          string          `json:"id" db:"id"`
    Name        string          `json:"name" db:"name"`
    Chain       string          `json:"chain" db:"chain"`
    Category    string          `json:"category" db:"category"`
    TVL         decimal.Decimal `json:"tvl" db:"tvl"`
    UpdatedAt   time.Time       `json:"updated_at" db:"updated_at"`
}

// 流动性池信息
type LiquidityPool struct {
    ID           string          `json:"id" db:"id"`
    ProtocolID   string          `json:"protocol_id" db:"protocol_id"`
    Token0       string          `json:"token0" db:"token0"`
    Token1       string          `json:"token1" db:"token1"`
    Reserve0     decimal.Decimal `json:"reserve0" db:"reserve0"`
    Reserve1     decimal.Decimal `json:"reserve1" db:"reserve1"`
    Price0       decimal.Decimal `json:"price0" db:"price0"`
    Price1       decimal.Decimal `json:"price1" db:"price1"`
    Volume24h    decimal.Decimal `json:"volume_24h" db:"volume_24h"`
    Fees24h      decimal.Decimal `json:"fees_24h" db:"fees_24h"`
    APR          decimal.Decimal `json:"apr" db:"apr"`
    UpdatedAt    time.Time       `json:"updated_at" db:"updated_at"`
}

// 借贷市场信息
type LendingMarket struct {
    ID              string          `json:"id" db:"id"`
    ProtocolID      string          `json:"protocol_id" db:"protocol_id"`
    Asset           string          `json:"asset" db:"asset"`
    SupplyAPY       decimal.Decimal `json:"supply_apy" db:"supply_apy"`
    BorrowAPY       decimal.Decimal `json:"borrow_apy" db:"borrow_apy"`
    TotalSupply     decimal.Decimal `json:"total_supply" db:"total_supply"`
    TotalBorrow     decimal.Decimal `json:"total_borrow" db:"total_borrow"`
    UtilizationRate decimal.Decimal `json:"utilization_rate" db:"utilization_rate"`
    UpdatedAt       time.Time       `json:"updated_at" db:"updated_at"`
}
```

**3. 数据库Schema设计**
```sql
-- migrations/001_initial_schema.sql

-- 协议表
CREATE TABLE protocols (
    id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    chain VARCHAR(20) NOT NULL,
    category VARCHAR(50) NOT NULL,
    tvl DECIMAL(20,2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 流动性池表
CREATE TABLE liquidity_pools (
    id VARCHAR(100) PRIMARY KEY,
    protocol_id VARCHAR(50) NOT NULL,
    token0 VARCHAR(42) NOT NULL,
    token1 VARCHAR(42) NOT NULL,
    reserve0 DECIMAL(30,18) DEFAULT 0,
    reserve1 DECIMAL(30,18) DEFAULT 0,
    price0 DECIMAL(30,18) DEFAULT 0,
    price1 DECIMAL(30,18) DEFAULT 0,
    volume_24h DECIMAL(20,2) DEFAULT 0,
    fees_24h DECIMAL(20,2) DEFAULT 0,
    apr DECIMAL(8,4) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (protocol_id) REFERENCES protocols(id)
);

-- 借贷市场表
CREATE TABLE lending_markets (
    id VARCHAR(100) PRIMARY KEY,
    protocol_id VARCHAR(50) NOT NULL,
    asset VARCHAR(42) NOT NULL,
    supply_apy DECIMAL(8,4) DEFAULT 0,
    borrow_apy DECIMAL(8,4) DEFAULT 0,
    total_supply DECIMAL(30,18) DEFAULT 0,
    total_borrow DECIMAL(30,18) DEFAULT 0,
    utilization_rate DECIMAL(8,4) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (protocol_id) REFERENCES protocols(id)
);

-- 创建索引
CREATE INDEX idx_pools_protocol ON liquidity_pools(protocol_id);
CREATE INDEX idx_pools_tokens ON liquidity_pools(token0, token1);
CREATE INDEX idx_markets_protocol ON lending_markets(protocol_id);
CREATE INDEX idx_markets_asset ON lending_markets(asset);
```

**4. 配置管理系统**
```go
// internal/shared/config/config.go
package config

import (
    "os"
    "strconv"
    "github.com/joho/godotenv"
)

type Config struct {
    // 数据库配置
    Database DatabaseConfig `json:"database"`
    
    // Redis配置
    Redis RedisConfig `json:"redis"`
    
    // 区块链配置
    Blockchain BlockchainConfig `json:"blockchain"`
    
    // 服务配置
    Services ServicesConfig `json:"services"`
}

type DatabaseConfig struct {
    Host     string `json:"host"`
    Port     int    `json:"port"`
    Name     string `json:"name"`
    User     string `json:"user"`
    Password string `json:"password"`
    SSLMode  string `json:"ssl_mode"`
}

type RedisConfig struct {
    Host     string `json:"host"`
    Port     int    `json:"port"`
    Password string `json:"password"`
    DB       int    `json:"db"`
}

type BlockchainConfig struct {
    EthereumRPC string `json:"ethereum_rpc"`
    BSCRpc      string `json:"bsc_rpc"`
    PolygonRPC  string `json:"polygon_rpc"`
}

type ServicesConfig struct {
    Collector CollectorConfig `json:"collector"`
    Processor ProcessorConfig `json:"processor"`
    Gateway   GatewayConfig   `json:"gateway"`
}

type CollectorConfig struct {
    Port           int `json:"port"`
    UpdateInterval int `json:"update_interval"` // 秒
}

type ProcessorConfig struct {
    Port       int `json:"port"`
    BatchSize  int `json:"batch_size"`
    WorkerNum  int `json:"worker_num"`
}

type GatewayConfig struct {
    Port         int    `json:"port"`
    RateLimit    int    `json:"rate_limit"`
    CacheTimeout int    `json:"cache_timeout"`
    JWTSecret    string `json:"jwt_secret"`
}

func Load() (*Config, error) {
    // 加载.env文件
    godotenv.Load()
    
    cfg := &Config{
        Database: DatabaseConfig{
            Host:     getEnv("DB_HOST", "localhost"),
            Port:     getEnvAsInt("DB_PORT", 5432),
            Name:     getEnv("DB_NAME", "defi_aggregator"),
            User:     getEnv("DB_USER", "postgres"),
            Password: getEnv("DB_PASSWORD", ""),
            SSLMode:  getEnv("DB_SSL_MODE", "disable"),
        },
        Redis: RedisConfig{
            Host:     getEnv("REDIS_HOST", "localhost"),
            Port:     getEnvAsInt("REDIS_PORT", 6379),
            Password: getEnv("REDIS_PASSWORD", ""),
            DB:       getEnvAsInt("REDIS_DB", 0),
        },
        Blockchain: BlockchainConfig{
            EthereumRPC: getEnv("ETHEREUM_RPC", "https://mainnet.infura.io/v3/YOUR_KEY"),
            BSCRpc:      getEnv("BSC_RPC", "https://bsc-dataseed.binance.org/"),
            PolygonRPC:  getEnv("POLYGON_RPC", "https://polygon-rpc.com/"),
        },
        Services: ServicesConfig{
            Collector: CollectorConfig{
                Port:           getEnvAsInt("COLLECTOR_PORT", 8001),
                UpdateInterval: getEnvAsInt("UPDATE_INTERVAL", 30),
            },
            Processor: ProcessorConfig{
                Port:      getEnvAsInt("PROCESSOR_PORT", 8002),
                BatchSize: getEnvAsInt("BATCH_SIZE", 100),
                WorkerNum: getEnvAsInt("WORKER_NUM", 10),
            },
            Gateway: GatewayConfig{
                Port:         getEnvAsInt("GATEWAY_PORT", 8000),
                RateLimit:    getEnvAsInt("RATE_LIMIT", 1000),
                CacheTimeout: getEnvAsInt("CACHE_TIMEOUT", 300),
                JWTSecret:    getEnv("JWT_SECRET", "your-secret-key"),
            },
        },
    }
    
    return cfg, nil
}

func getEnv(key, fallback string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return fallback
}

func getEnvAsInt(key string, fallback int) int {
    if value := os.Getenv(key); value != "" {
        if intVal, err := strconv.Atoi(value); err == nil {
            return intVal
        }
    }
    return fallback
}
```

#### Day 12 任务：核心业务实现

**1. 数据收集服务实现**
```go
// internal/collector/ethereum/client.go
package ethereum

import (
    "context"
    "math/big"
    "github.com/ethereum/go-ethereum/ethclient"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/accounts/abi/bind"
)

type Client struct {
    ethClient  *ethclient.Client
    contracts  map[string]common.Address
}

func NewClient(rpcURL string) (*Client, error) {
    client, err := ethclient.Dial(rpcURL)
    if err != nil {
        return nil, err
    }
    
    contracts := map[string]common.Address{
        "uniswap_factory": common.HexToAddress("0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f"),
        "compound_comptroller": common.HexToAddress("0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B"),
        // 更多合约地址...
    }
    
    return &Client{
        ethClient: client,
        contracts: contracts,
    }, nil
}

func (c *Client) GetBlockNumber() (*big.Int, error) {
    return c.ethClient.BlockNumber(context.Background())
}

func (c *Client) GetPairReserves(pairAddress common.Address) (*big.Int, *big.Int, error) {
    // 实现Uniswap pair合约调用
    // 这里需要生成合约ABI绑定
    
    // 示例：调用getReserves方法
    caller := bind.CallOpts{}
    
    // 实际实现需要合约ABI绑定
    // reserve0, reserve1, timestamp, err := pairContract.GetReserves(&caller)
    
    // 临时返回示例数据
    return big.NewInt(1000000), big.NewInt(2000000), nil
}
```

**2. 数据处理服务实现**
```go
// internal/processor/calculator/apy.go
package calculator

import (
    "math"
    "github.com/shopspring/decimal"
)

type APYCalculator struct{}

func NewAPYCalculator() *APYCalculator {
    return &APYCalculator{}
}

// 计算Uniswap LP的APY
func (c *APYCalculator) CalculateUniswapAPY(
    volume24h decimal.Decimal,
    tvl decimal.Decimal,
    feeRate decimal.Decimal,
) decimal.Decimal {
    if tvl.IsZero() {
        return decimal.Zero
    }
    
    // 日收益率 = (24小时交易量 * 手续费率) / TVL
    dailyReturn := volume24h.Mul(feeRate).Div(tvl)
    
    // 年化收益率 = (1 + 日收益率)^365 - 1
    dailyReturnFloat, _ := dailyReturn.Float64()
    apy := math.Pow(1+dailyReturnFloat, 365) - 1
    
    return decimal.NewFromFloat(apy)
}

// 计算复合收益APY
func (c *APYCalculator) CalculateCompoundAPY(
    apr decimal.Decimal,
    compoundFrequency int, // 每年复投次数
) decimal.Decimal {
    aprFloat, _ := apr.Float64()
    freq := float64(compoundFrequency)
    
    // APY = (1 + APR/n)^n - 1
    apy := math.Pow(1+aprFloat/freq, freq) - 1
    
    return decimal.NewFromFloat(apy)
}

// 计算流动性挖矿收益
func (c *APYCalculator) CalculateFarmingAPY(
    rewardPerSecond decimal.Decimal,
    rewardTokenPrice decimal.Decimal,
    totalStaked decimal.Decimal,
    stakedTokenPrice decimal.Decimal,
) decimal.Decimal {
    if totalStaked.IsZero() {
        return decimal.Zero
    }
    
    // 年收益 = 每秒奖励 * 秒/年 * 奖励代币价格
    secondsPerYear := decimal.NewFromInt(365 * 24 * 3600)
    yearlyRewardValue := rewardPerSecond.Mul(secondsPerYear).Mul(rewardTokenPrice)
    
    // 总质押价值
    totalStakedValue := totalStaked.Mul(stakedTokenPrice)
    
    // APY = 年收益 / 总质押价值
    return yearlyRewardValue.Div(totalStakedValue)
}
```

**3. API网关实现**
```go
// internal/gateway/handlers/defi.go
package handlers

import (
    "net/http"
    "strconv"
    "github.com/gin-gonic/gin"
    "github.com/your-project/internal/shared/models"
    "github.com/your-project/internal/shared/database"
)

type DeFiHandler struct {
    db *database.DB
}

func NewDeFiHandler(db *database.DB) *DeFiHandler {
    return &DeFiHandler{db: db}
}

// 获取协议列表
func (h *DeFiHandler) GetProtocols(c *gin.Context) {
    // 解析查询参数
    chain := c.Query("chain")
    category := c.Query("category")
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
    offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
    
    // 构建查询条件
    query := h.db.Model(&models.Protocol{})
    if chain != "" {
        query = query.Where("chain = ?", chain)
    }
    if category != "" {
        query = query.Where("category = ?", category)
    }
    
    // 执行查询
    var protocols []models.Protocol
    var total int64
    
    query.Count(&total)
    err := query.Limit(limit).Offset(offset).
        Order("tvl DESC").Find(&protocols).Error
    
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to fetch protocols",
        })
        return
    }
    
    // 返回结果
    c.JSON(http.StatusOK, gin.H{
        "data": protocols,
        "pagination": gin.H{
            "total":  total,
            "limit":  limit,
            "offset": offset,
        },
    })
}

// 获取流动性池列表
func (h *DeFiHandler) GetLiquidityPools(c *gin.Context) {
    protocolID := c.Query("protocol_id")
    token := c.Query("token")
    sortBy := c.DefaultQuery("sort_by", "tvl")
    order := c.DefaultQuery("order", "desc")
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
    offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
    
    query := h.db.Model(&models.LiquidityPool{})
    
    if protocolID != "" {
        query = query.Where("protocol_id = ?", protocolID)
    }
    
    if token != "" {
        query = query.Where("token0 = ? OR token1 = ?", token, token)
    }
    
    // 构建排序
    orderBy := sortBy + " " + order
    
    var pools []models.LiquidityPool
    var total int64
    
    query.Count(&total)
    err := query.Limit(limit).Offset(offset).
        Order(orderBy).Find(&pools).Error
    
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to fetch liquidity pools",
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "data": pools,
        "pagination": gin.H{
            "total":  total,
            "limit":  limit,
            "offset": offset,
        },
    })
}

// 获取最优收益率
func (h *DeFiHandler) GetBestYields(c *gin.Context) {
    asset := c.Query("asset")
    minAmount := c.Query("min_amount")
    riskLevel := c.DefaultQuery("risk_level", "medium")
    
    // 构建复杂查询，找出最优收益率
    var results []struct {
        models.LendingMarket
        ProtocolName string `json:"protocol_name"`
        RiskScore    int    `json:"risk_score"`
    }
    
    query := `
        SELECT lm.*, p.name as protocol_name, 
               CASE 
                   WHEN p.category = 'blue-chip' THEN 1
                   WHEN p.category = 'established' THEN 2
                   ELSE 3
               END as risk_score
        FROM lending_markets lm
        JOIN protocols p ON lm.protocol_id = p.id
        WHERE 1=1
    `
    
    params := []interface{}{}
    
    if asset != "" {
        query += " AND lm.asset = ?"
        params = append(params, asset)
    }
    
    if minAmount != "" {
        query += " AND lm.total_supply >= ?"
        params = append(params, minAmount)
    }
    
    switch riskLevel {
    case "low":
        query += " AND risk_score = 1"
    case "medium":
        query += " AND risk_score <= 2"
    case "high":
        // 包含所有风险等级
    }
    
    query += " ORDER BY lm.supply_apy DESC LIMIT 10"
    
    err := h.db.Raw(query, params...).Scan(&results).Error
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to fetch best yields",
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "data": results,
    })
}
```

**4. Docker部署配置**
```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: defi_aggregator
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

  collector:
    build: 
      context: .
      target: collector
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
      - ETHEREUM_RPC=${ETHEREUM_RPC}
    depends_on:
      - postgres
      - redis
    ports:
      - "8001:8001"

  processor:
    build: 
      context: .
      target: processor
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      - postgres
      - redis
    ports:
      - "8002:8002"

  gateway:
    build: 
      context: .
      target: gateway
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      - postgres
      - redis
    ports:
      - "8000:8000"

volumes:
  postgres_data:
  redis_data:
```

```dockerfile
# Dockerfile
FROM golang:1.19-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .

# 构建收集器服务
FROM builder AS collector-build
RUN go build -o collector ./cmd/collector

# 构建处理器服务
FROM builder AS processor-build
RUN go build -o processor ./cmd/processor

# 构建网关服务
FROM builder AS gateway-build
RUN go build -o gateway ./cmd/gateway

# 收集器运行时
FROM alpine:latest AS collector
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=collector-build /app/collector .
CMD ["./collector"]

# 处理器运行时
FROM alpine:latest AS processor
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=processor-build /app/processor .
CMD ["./processor"]

# 网关运行时
FROM alpine:latest AS gateway
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=gateway-build /app/gateway .
CMD ["./gateway"]
```

---

## 🔥 项目2：Web3交易监控系统 (Day 13-14)

### 📋 项目概述
**项目名称**: Web3 Transaction Monitor
**核心价值**: 实时监控区块链大额交易和异常行为，提供智能告警
**技术亮点**: 事件驱动架构 + gRPC微服务 + 实时WebSocket推送

### 🎯 功能需求详细定义
```yaml
核心功能模块:
  1. 交易监听服务:
     - 多链交易实时监听
     - 智能合约事件监听
     - 大额交易自动识别
     - MEV交易检测

  2. 分析引擎服务:
     - 交易模式识别
     - 异常行为检测
     - 地址标签和分类
     - 风险评估算法

  3. 通知推送服务:
     - 实时WebSocket推送
     - 邮件/短信告警
     - Webhook集成
     - 告警规则配置

  4. 数据存储服务:
     - 交易数据存储
     - 地址标签管理
     - 告警历史记录
     - 用户配置存储
```

### 💻 核心代码实现指南

#### Day 13 任务：监听和分析

**1. 交易监听服务**
```go
// internal/monitor/listener/ethereum.go
package listener

import (
    "context"
    "log"
    "math/big"
    "github.com/ethereum/go-ethereum"
    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/ethclient"
    "github.com/ethereum/go-ethereum/common"
)

type EthereumListener struct {
    client      *ethclient.Client
    subscribers []TransactionSubscriber
    threshold   *big.Int // 大额交易阈值
}

type TransactionSubscriber interface {
    OnTransaction(tx *Transaction) error
}

type Transaction struct {
    Hash        string          `json:"hash"`
    From        string          `json:"from"`
    To          string          `json:"to"`
    Value       *big.Int        `json:"value"`
    GasPrice    *big.Int        `json:"gas_price"`
    GasUsed     uint64          `json:"gas_used"`
    BlockNumber uint64          `json:"block_number"`
    Timestamp   int64           `json:"timestamp"`
    Status      uint64          `json:"status"`
    IsLarge     bool            `json:"is_large"`
    Category    string          `json:"category"`
}

func NewEthereumListener(rpcURL string, thresholdETH float64) (*EthereumListener, error) {
    client, err := ethclient.Dial(rpcURL)
    if err != nil {
        return nil, err
    }
    
    // 将ETH转换为Wei
    thresholdWei := new(big.Int)
    thresholdWei.SetString(fmt.Sprintf("%.0f", thresholdETH*1e18), 10)
    
    return &EthereumListener{
        client:      client,
        subscribers: make([]TransactionSubscriber, 0),
        threshold:   thresholdWei,
    }, nil
}

func (l *EthereumListener) Subscribe(subscriber TransactionSubscriber) {
    l.subscribers = append(l.subscribers, subscriber)
}

func (l *EthereumListener) Start(ctx context.Context) error {
    headers := make(chan *types.Header)
    
    sub, err := l.client.SubscribeNewHead(ctx, headers)
    if err != nil {
        return err
    }
    
    defer sub.Unsubscribe()
    
    for {
        select {
        case err := <-sub.Err():
            log.Printf("Subscription error: %v", err)
            return err
        case header := <-headers:
            if err := l.processBlock(ctx, header.Number); err != nil {
                log.Printf("Error processing block %d: %v", header.Number, err)
            }
        case <-ctx.Done():
            return ctx.Err()
        }
    }
}

func (l *EthereumListener) processBlock(ctx context.Context, blockNumber *big.Int) error {
    block, err := l.client.BlockByNumber(ctx, blockNumber)
    if err != nil {
        return err
    }
    
    for _, tx := range block.Transactions() {
        transaction := l.convertTransaction(tx, block)
        
        // 分析交易类型
        transaction.Category = l.analyzeTransactionCategory(transaction)
        transaction.IsLarge = transaction.Value.Cmp(l.threshold) > 0
        
        // 通知所有订阅者
        for _, subscriber := range l.subscribers {
            if err := subscriber.OnTransaction(transaction); err != nil {
                log.Printf("Subscriber error: %v", err)
            }
        }
    }
    
    return nil
}

func (l *EthereumListener) convertTransaction(tx *types.Transaction, block *types.Block) *Transaction {
    var to string
    if tx.To() != nil {
        to = tx.To().Hex()
    }
    
    return &Transaction{
        Hash:        tx.Hash().Hex(),
        From:        l.getFromAddress(tx),
        To:          to,
        Value:       tx.Value(),
        GasPrice:    tx.GasPrice(),
        BlockNumber: block.NumberU64(),
        Timestamp:   int64(block.Time()),
    }
}

func (l *EthereumListener) analyzeTransactionCategory(tx *Transaction) string {
    // 简单的交易类型分析
    if tx.To == "" {
        return "contract_creation"
    }
    
    if tx.Value.Cmp(big.NewInt(0)) == 0 {
        return "contract_interaction"
    }
    
    if tx.Value.Cmp(l.threshold) > 0 {
        return "large_transfer"
    }
    
    return "normal_transfer"
}
```

**2. 异常检测引擎**
```go
// internal/analyzer/anomaly/detector.go
package anomaly

import (
    "math/big"
    "time"
    "github.com/your-project/internal/shared/models"
)

type AnomalyDetector struct {
    addressTracker map[string]*AddressActivity
    patterns       []Pattern
}

type AddressActivity struct {
    Address           string
    TotalVolume       *big.Int
    TransactionCount  int
    LastActivityTime  time.Time
    DailyVolume       *big.Int
    DailyTxCount      int
    UnusualPatterns   []string
}

type Pattern interface {
    Detect(activity *AddressActivity, tx *Transaction) []Anomaly
}

type Anomaly struct {
    Type        string    `json:"type"`
    Severity    string    `json:"severity"`
    Description string    `json:"description"`
    Address     string    `json:"address"`
    Transaction string    `json:"transaction"`
    Timestamp   time.Time `json:"timestamp"`
    Score       float64   `json:"score"`
}

// 高频交易检测
type HighFrequencyPattern struct {
    timeWindow    time.Duration
    txThreshold   int
    volumeThreshold *big.Int
}

func (p *HighFrequencyPattern) Detect(activity *AddressActivity, tx *Transaction) []Anomaly {
    var anomalies []Anomaly
    
    // 检查是否在短时间内有大量交易
    if activity.DailyTxCount > p.txThreshold {
        anomalies = append(anomalies, Anomaly{
            Type:        "high_frequency",
            Severity:    "medium",
            Description: fmt.Sprintf("Address has %d transactions in 24h", activity.DailyTxCount),
            Address:     activity.Address,
            Transaction: tx.Hash,
            Timestamp:   time.Now(),
            Score:       float64(activity.DailyTxCount) / float64(p.txThreshold),
        })
    }
    
    return anomalies
}

// 异常金额检测
type UnusualAmountPattern struct {
    historicalAverage map[string]*big.Int
    deviationFactor   float64
}

func (p *UnusualAmountPattern) Detect(activity *AddressActivity, tx *Transaction) []Anomaly {
    var anomalies []Anomaly
    
    avgAmount := p.historicalAverage[activity.Address]
    if avgAmount == nil {
        return anomalies
    }
    
    // 计算当前交易金额与历史平均的偏差
    deviation := new(big.Float).Quo(
        new(big.Float).SetInt(tx.Value),
        new(big.Float).SetInt(avgAmount),
    )
    
    deviationFloat, _ := deviation.Float64()
    
    if deviationFloat > p.deviationFactor {
        anomalies = append(anomalies, Anomaly{
            Type:        "unusual_amount",
            Severity:    "high",
            Description: fmt.Sprintf("Transaction amount %.2fx larger than average", deviationFloat),
            Address:     activity.Address,
            Transaction: tx.Hash,
            Timestamp:   time.Now(),
            Score:       deviationFloat / p.deviationFactor,
        })
    }
    
    return anomalies
}

// 洗钱模式检测
type MoneyLaunderingPattern struct {
    hopLimit int
    timeWindow time.Duration
}

func (p *MoneyLaunderingPattern) Detect(activity *AddressActivity, tx *Transaction) []Anomaly {
    // 检测资金快速流转模式
    // 这需要图数据库或更复杂的数据结构来追踪资金流
    
    // 简化版本：检测短时间内的多跳转账
    var anomalies []Anomaly
    
    // 实际实现需要追踪交易链
    
    return anomalies
}
```

#### Day 14 任务：通知和展示

**1. WebSocket推送服务**
```go
// internal/notification/websocket/hub.go
package websocket

import (
    "encoding/json"
    "log"
    "net/http"
    "github.com/gorilla/websocket"
    "github.com/gin-gonic/gin"
)

type Hub struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

type Client struct {
    hub    *Hub
    conn   *websocket.Conn
    send   chan []byte
    userID string
    filters ClientFilters
}

type ClientFilters struct {
    MinAmount    string   `json:"min_amount"`
    Addresses    []string `json:"addresses"`
    Tokens       []string `json:"tokens"`
    AnomalyTypes []string `json:"anomaly_types"`
}

type Message struct {
    Type      string      `json:"type"`
    Data      interface{} `json:"data"`
    Timestamp int64       `json:"timestamp"`
}

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true // 生产环境需要更严格的检查
    },
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.clients[client] = true
            log.Printf("Client registered: %s", client.userID)
            
        case client := <-h.unregister:
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
                log.Printf("Client unregistered: %s", client.userID)
            }
            
        case message := <-h.broadcast:
            for client := range h.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(h.clients, client)
                }
            }
        }
    }
}

func (h *Hub) BroadcastTransaction(tx *Transaction) {
    message := Message{
        Type:      "transaction",
        Data:      tx,
        Timestamp: time.Now().Unix(),
    }
    
    h.broadcastToFilteredClients(message, func(client *Client) bool {
        return h.matchesTransactionFilter(client.filters, tx)
    })
}

func (h *Hub) BroadcastAnomaly(anomaly *Anomaly) {
    message := Message{
        Type:      "anomaly",
        Data:      anomaly,
        Timestamp: time.Now().Unix(),
    }
    
    h.broadcastToFilteredClients(message, func(client *Client) bool {
        return h.matchesAnomalyFilter(client.filters, anomaly)
    })
}

func (h *Hub) broadcastToFilteredClients(message Message, filter func(*Client) bool) {
    data, err := json.Marshal(message)
    if err != nil {
        log.Printf("Error marshaling message: %v", err)
        return
    }
    
    for client := range h.clients {
        if filter(client) {
            select {
            case client.send <- data:
            default:
                close(client.send)
                delete(h.clients, client)
            }
        }
    }
}

func (h *Hub) HandleWebSocket(c *gin.Context) {
    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        log.Printf("WebSocket upgrade error: %v", err)
        return
    }
    
    userID := c.Query("user_id")
    if userID == "" {
        userID = "anonymous"
    }
    
    client := &Client{
        hub:    h,
        conn:   conn,
        send:   make(chan []byte, 256),
        userID: userID,
    }
    
    client.hub.register <- client
    
    go client.writePump()
    go client.readPump()
}

func (c *Client) readPump() {
    defer func() {
        c.hub.unregister <- c
        c.conn.Close()
    }()
    
    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            break
        }
        
        // 处理客户端发送的过滤条件更新
        var filterUpdate ClientFilters
        if err := json.Unmarshal(message, &filterUpdate); err == nil {
            c.filters = filterUpdate
            log.Printf("Updated filters for client %s", c.userID)
        }
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()
    
    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            
            if err := c.conn.WriteMessage(websocket.TextMessage, message); err != nil {
                return
            }
        }
    }
}
```

**2. gRPC服务通信**
```protobuf
// api/proto/monitor.proto
syntax = "proto3";

package monitor;

option go_package = "./pb";

service MonitorService {
    rpc SubscribeTransactions(TransactionFilter) returns (stream TransactionEvent);
    rpc SubscribeAnomalies(AnomalyFilter) returns (stream AnomalyEvent);
    rpc GetAddressAnalysis(AddressRequest) returns (AddressAnalysis);
    rpc UpdateAlertRules(AlertRules) returns (UpdateResponse);
}

message TransactionFilter {
    repeated string addresses = 1;
    string min_amount = 2;
    repeated string tokens = 3;
    repeated string categories = 4;
}

message AnomalyFilter {
    repeated string types = 1;
    string min_severity = 2;
    repeated string addresses = 3;
}

message TransactionEvent {
    string hash = 1;
    string from_address = 2;
    string to_address = 3;
    string value = 4;
    uint64 block_number = 5;
    int64 timestamp = 6;
    string category = 7;
    bool is_large = 8;
}

message AnomalyEvent {
    string type = 1;
    string severity = 2;
    string description = 3;
    string address = 4;
    string transaction = 5;
    int64 timestamp = 6;
    double score = 7;
}

message AddressRequest {
    string address = 1;
    int32 days = 2;
}

message AddressAnalysis {
    string address = 1;
    string total_volume = 2;
    int32 transaction_count = 3;
    repeated string labels = 4;
    double risk_score = 5;
    repeated AnomalyEvent anomalies = 6;
}

message AlertRules {
    string user_id = 1;
    repeated AlertRule rules = 2;
}

message AlertRule {
    string name = 1;
    TransactionFilter transaction_filter = 2;
    AnomalyFilter anomaly_filter = 3;
    repeated string notification_channels = 4;
    bool enabled = 5;
}

message UpdateResponse {
    bool success = 1;
    string message = 2;
}
```

---

## 🚀 项目3：NFT数据分析器 (Day 15)

### 📋 项目概述 (快速开发模式)
**项目名称**: NFT Market Analyzer
**核心价值**: NFT市场数据分析和稀有度评估
**技术亮点**: GraphQL API + 时序数据处理 + 复杂算法实现

### 💻 核心功能实现 (一天完成)

**1. NFT数据模型**
```go
// internal/nft/models/nft.go
package models

type NFTCollection struct {
    Address     string  `json:"address"`
    Name        string  `json:"name"`
    Symbol      string  `json:"symbol"`
    TotalSupply int     `json:"total_supply"`
    FloorPrice  float64 `json:"floor_price"`
    Volume24h   float64 `json:"volume_24h"`
    Owners      int     `json:"owners"`
}

type NFT struct {
    TokenID      string                 `json:"token_id"`
    Collection   string                 `json:"collection"`
    Name         string                 `json:"name"`
    Description  string                 `json:"description"`
    Image        string                 `json:"image"`
    Attributes   []NFTAttribute         `json:"attributes"`
    Rarity       RarityScore           `json:"rarity"`
    PriceHistory []PricePoint          `json:"price_history"`
}

type NFTAttribute struct {
    TraitType string `json:"trait_type"`
    Value     string `json:"value"`
    Rarity    float64 `json:"rarity"` // 0-1，越小越稀有
}

type RarityScore struct {
    Rank         int     `json:"rank"`
    Score        float64 `json:"score"`
    Percentile   float64 `json:"percentile"`
    Method       string  `json:"method"`
}
```

**2. 稀有度计算算法**
```go
// internal/nft/rarity/calculator.go
package rarity

import (
    "math"
    "sort"
)

type RarityCalculator struct {
    method string
}

func NewRarityCalculator(method string) *RarityCalculator {
    return &RarityCalculator{method: method}
}

// 统计稀有度计算法
func (r *RarityCalculator) CalculateStatisticalRarity(nfts []NFT) {
    // 1. 统计每个属性值的出现频率
    traitCounts := make(map[string]map[string]int)
    
    for _, nft := range nfts {
        for _, attr := range nft.Attributes {
            if traitCounts[attr.TraitType] == nil {
                traitCounts[attr.TraitType] = make(map[string]int)
            }
            traitCounts[attr.TraitType][attr.Value]++
        }
    }
    
    // 2. 计算每个NFT的稀有度分数
    for i := range nfts {
        score := 0.0
        
        for _, attr := range nfts[i].Attributes {
            traitTotal := 0
            for _, count := range traitCounts[attr.TraitType] {
                traitTotal += count
            }
            
            frequency := float64(traitCounts[attr.TraitType][attr.Value]) / float64(traitTotal)
            nfts[i].Attributes[j].Rarity = frequency
            
            // 使用倒数计算稀有度分数
            score += 1.0 / frequency
        }
        
        nfts[i].Rarity.Score = score
        nfts[i].Rarity.Method = "statistical"
    }
    
    // 3. 排序并分配排名
    sort.Slice(nfts, func(i, j int) bool {
        return nfts[i].Rarity.Score > nfts[j].Rarity.Score
    })
    
    for i := range nfts {
        nfts[i].Rarity.Rank = i + 1
        nfts[i].Rarity.Percentile = float64(i+1) / float64(len(nfts)) * 100
    }
}

// 信息论稀有度计算法
func (r *RarityCalculator) CalculateInformationRarity(nfts []NFT) {
    traitCounts := make(map[string]map[string]int)
    totalSupply := len(nfts)
    
    // 统计频率
    for _, nft := range nfts {
        for _, attr := range nft.Attributes {
            if traitCounts[attr.TraitType] == nil {
                traitCounts[attr.TraitType] = make(map[string]int)
            }
            traitCounts[attr.TraitType][attr.Value]++
        }
    }
    
    // 计算信息熵
    for i := range nfts {
        entropy := 0.0
        
        for _, attr := range nfts[i].Attributes {
            probability := float64(traitCounts[attr.TraitType][attr.Value]) / float64(totalSupply)
            
            if probability > 0 {
                entropy -= probability * math.Log2(probability)
            }
        }
        
        nfts[i].Rarity.Score = entropy
        nfts[i].Rarity.Method = "information_theory"
    }
}
```

**3. GraphQL Schema和Resolver**
```graphql
# api/graphql/schema.graphql
type Query {
    collection(address: String!): NFTCollection
    collections(limit: Int, offset: Int, sortBy: String): [NFTCollection!]!
    nft(collection: String!, tokenId: String!): NFT
    nfts(collection: String!, filter: NFTFilter): [NFT!]!
    rarityRanking(collection: String!, method: String): [NFT!]!
    priceAnalysis(collection: String!, period: String): PriceAnalysis
}

type Mutation {
    refreshCollection(address: String!): Boolean
    updateRarityScores(collection: String!, method: String): Boolean
}

type Subscription {
    priceUpdates(collection: String!): PriceUpdate
    newListings(collection: String!): NFTListing
}

input NFTFilter {
    minPrice: Float
    maxPrice: Float
    attributes: [AttributeFilter!]
    rarityRange: RarityRange
}

input AttributeFilter {
    traitType: String!
    values: [String!]!
}

input RarityRange {
    minRank: Int
    maxRank: Int
    minPercentile: Float
    maxPercentile: Float
}

type PriceAnalysis {
    collection: String!
    period: String!
    floorPrice: Float!
    averagePrice: Float!
    volume: Float!
    sales: Int!
    priceChanges: [PriceChange!]!
    volatility: Float!
}

type PriceChange {
    timestamp: Int!
    price: Float!
    volume: Float!
}
```

```go
// internal/nft/graphql/resolver.go
package graphql

import (
    "context"
    "github.com/your-project/internal/nft/models"
    "github.com/your-project/internal/nft/service"
)

type Resolver struct {
    nftService *service.NFTService
}

func (r *queryResolver) Collection(ctx context.Context, address string) (*models.NFTCollection, error) {
    return r.nftService.GetCollection(address)
}

func (r *queryResolver) RarityRanking(ctx context.Context, collection string, method *string) ([]*models.NFT, error) {
    if method == nil {
        defaultMethod := "statistical"
        method = &defaultMethod
    }
    
    return r.nftService.GetRarityRanking(collection, *method)
}

func (r *queryResolver) PriceAnalysis(ctx context.Context, collection string, period string) (*models.PriceAnalysis, error) {
    return r.nftService.GetPriceAnalysis(collection, period)
}

func (r *mutationResolver) UpdateRarityScores(ctx context.Context, collection string, method string) (bool, error) {
    return r.nftService.UpdateRarityScores(collection, method)
}
```

---

## 🎯 最终项目验收和面试准备

### ✅ 项目完整性检查清单

**技术实现验收**
- [ ] 所有核心功能完整实现
- [ ] 单元测试覆盖率达到80%+
- [ ] API文档完整准确
- [ ] Docker容器化部署成功
- [ ] 性能测试通过基准
- [ ] 错误处理和边界情况覆盖
- [ ] 代码质量符合Go最佳实践
- [ ] 安全性检查通过

**文档和展示准备**
- [ ] README文档详细完整
- [ ] API文档自动生成
- [ ] 架构图和流程图制作
- [ ] 部署指南一键执行
- [ ] 演示脚本准备完毕
- [ ] 技术难点总结文档
- [ ] 改进方案和扩展计划
- [ ] 商业价值和应用场景说明

**面试材料准备**
- [ ] 项目介绍PPT (5-10分钟)
- [ ] 代码演示环境准备
- [ ] 技术问题答案整理
- [ ] 项目优缺点分析
- [ ] 团队协作经验总结
- [ ] 学习成长心得准备

### 🏆 成功标准最终确认

**90%+转正成功率指标:**
1. **技术深度展示** (40%权重)
   - 微服务架构设计合理
   - Web3业务理解深入
   - Go语言使用熟练
   - 问题解决能力强

2. **项目完整度** (25%权重)
   - 3个项目功能完整
   - 代码质量优秀
   - 部署运行稳定
   - 文档完整清晰

3. **学习成长体现** (20%权重)
   - 20天学习成果显著
   - 技术栈快速掌握
   - 主动学习能力强
   - 适应能力优秀

4. **沟通表达能力** (10%权重)
   - 技术表达清晰
   - 项目介绍逻辑
   - 问题回答准确
   - 团队协作意识

5. **商业理解力** (5%权重)
   - Web3行业认知
   - 产品思维体现
   - 用户价值导向
   - 技术选型合理

---

**🎯 通过这份详细的项目实施指导，您将在20天内完成从理论学习到项目实战的完整转换！**
**💪 每个项目都是您技能证明的有力证据，每行代码都是您成长路上的坚实足迹！**
**🚀 相信经过这20天的全力冲刺，您一定能够成功实现职业转型目标！**