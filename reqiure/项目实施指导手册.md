# ğŸ› ï¸ 20å¤©Web3é¡¹ç›®å®æ–½æŒ‡å¯¼æ‰‹å†Œ

## ğŸ¯ é¡¹ç›®æ€»è§ˆ

### ğŸ“Š ä¸‰å¤§æ ¸å¿ƒé¡¹ç›®è§„åˆ’
| é¡¹ç›® | æ—¶é—´ | æŠ€æœ¯æ ˆ | æ ¸å¿ƒåŠŸèƒ½ | å±•ç¤ºäº®ç‚¹ |
|------|------|--------|----------|----------|
| **DeFiæ•°æ®èšåˆå™¨** | Day 11-12 | Go+Gin+PostgreSQL+Redis | å®æ—¶DeFiæ•°æ®æ”¶é›†åˆ†æ | å¾®æœåŠ¡æ¶æ„+é«˜å¹¶å‘ |
| **Web3äº¤æ˜“ç›‘æ§** | Day 13-14 | Go+gRPC+MongoDB+WebSocket | åŒºå—é“¾äº¤æ˜“å®æ—¶ç›‘æ§ | äº‹ä»¶é©±åŠ¨+å®æ—¶æ¨é€ |
| **NFTæ•°æ®åˆ†æå™¨** | Day 15 | Go+Fiber+GraphQL+TimescaleDB | NFTå¸‚åœºæ•°æ®åˆ†æ | GraphQL API+æ—¶åºæ•°æ® |

### ğŸ† é¡¹ç›®æˆåŠŸæ ‡å‡†
```yaml
æŠ€æœ¯æ ‡å‡†:
  - ä»£ç è´¨é‡: ç¬¦åˆGoæœ€ä½³å®è·µï¼Œå•å…ƒæµ‹è¯•è¦†ç›–ç‡>80%
  - æ¶æ„è®¾è®¡: æ¸…æ™°çš„åˆ†å±‚æ¶æ„ï¼Œè‰¯å¥½çš„æ¨¡å—åŒ–
  - æ€§èƒ½è¡¨ç°: APIå“åº”æ—¶é—´<100msï¼Œæ”¯æŒå¹¶å‘1000+
  - éƒ¨ç½²æ–¹å¼: Dockerå®¹å™¨åŒ–ï¼Œä¸€é”®éƒ¨ç½²

ä¸šåŠ¡æ ‡å‡†:
  - åŠŸèƒ½å®Œæ•´: æ ¸å¿ƒåŠŸèƒ½å®Œå…¨å®ç°ï¼Œè¾¹ç•Œæƒ…å†µå¤„ç†
  - æ•°æ®å‡†ç¡®: ä¸ä¸»æµå¹³å°æ•°æ®ä¸€è‡´æ€§>99%
  - ç”¨æˆ·ä½“éªŒ: ç•Œé¢å‹å¥½ï¼Œæ“ä½œæµç•…
  - æ‰©å±•æ€§: æ”¯æŒæ–°åŠŸèƒ½å¿«é€Ÿæ·»åŠ 

å±•ç¤ºæ ‡å‡†:
  - æ–‡æ¡£å®Œæ•´: READMEã€APIæ–‡æ¡£ã€éƒ¨ç½²æŒ‡å—
  - æ¼”ç¤ºæµç•…: 5åˆ†é’Ÿå®Œæ•´åŠŸèƒ½æ¼”ç¤º
  - æŠ€æœ¯æ·±åº¦: èƒ½è§£é‡Šæ ¸å¿ƒæŠ€æœ¯é€‰å‹å’Œéš¾ç‚¹
  - å•†ä¸šç†è§£: å±•ç¤ºå¯¹Web3ä¸šåŠ¡çš„æ·±åº¦ç†è§£
```

---

## ğŸ—ï¸ é¡¹ç›®1ï¼šDeFiæ•°æ®èšåˆå™¨ (Day 11-12)

### ğŸ“‹ é¡¹ç›®æ¦‚è¿°
**é¡¹ç›®åç§°**: DeFi Protocol Data Aggregator
**æ ¸å¿ƒä»·å€¼**: å®æ—¶èšåˆä¸»æµDeFiåè®®æ•°æ®ï¼Œæä¾›ç»Ÿä¸€APIè®¿é—®
**æŠ€æœ¯äº®ç‚¹**: å¾®æœåŠ¡æ¶æ„ + é«˜å¹¶å‘æ•°æ®å¤„ç† + æ™ºèƒ½ç¼“å­˜ç­–ç•¥

### ğŸ¯ åŠŸèƒ½éœ€æ±‚è¯¦ç»†å®šä¹‰
```yaml
æ ¸å¿ƒåŠŸèƒ½æ¨¡å—:
  1. æ•°æ®æ”¶é›†æœåŠ¡:
     - å®æ—¶ç›‘å¬Uniswap/Sushiswapæ± å­æ•°æ®
     - è·å–Compound/Aaveå€Ÿè´·åˆ©ç‡
     - è¿½è¸ªTVLå’Œäº¤æ˜“é‡å˜åŒ–
     - ä»·æ ¼å‘ç°å’Œå¥—åˆ©æœºä¼šè¯†åˆ«

  2. æ•°æ®å¤„ç†æœåŠ¡:
     - æ•°æ®æ¸…æ´—å’Œæ ‡å‡†åŒ–
     - å®æ—¶è®¡ç®—APY/APR
     - é£é™©è¯„ä¼°å’Œè¯„åˆ†
     - è¶‹åŠ¿åˆ†æå’Œé¢„æµ‹

  3. APIç½‘å…³æœåŠ¡:
     - RESTful APIè®¾è®¡
     - æ•°æ®èšåˆå’Œè¿‡æ»¤
     - è®¿é—®æ§åˆ¶å’Œé™æµ
     - å“åº”æ ¼å¼æ ‡å‡†åŒ–

  4. æ•°æ®å­˜å‚¨å±‚:
     - å®æ—¶æ•°æ®ç¼“å­˜(Redis)
     - å†å²æ•°æ®å­˜å‚¨(PostgreSQL)
     - æ•°æ®å¤‡ä»½å’Œæ¢å¤
     - æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–
```

### ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ•°æ®æ”¶é›†æœåŠ¡   â”‚    â”‚   æ•°æ®å¤„ç†æœåŠ¡   â”‚    â”‚   APIç½‘å…³æœåŠ¡   â”‚
â”‚  (Collector)    â”‚    â”‚  (Processor)    â”‚    â”‚   (Gateway)     â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ åŒºå—é“¾ç›‘å¬     â”‚â—„â”€â”€â–ºâ”‚ â€¢ æ•°æ®æ¸…æ´—       â”‚â—„â”€â”€â–ºâ”‚ â€¢ RESTful API   â”‚
â”‚ â€¢ åè®®æ•°æ®æŠ“å–   â”‚    â”‚ â€¢ æŒ‡æ ‡è®¡ç®—       â”‚    â”‚ â€¢ å“åº”èšåˆ       â”‚
â”‚ â€¢ å®æ—¶ä»·æ ¼æ›´æ–°   â”‚    â”‚ â€¢ é£é™©è¯„ä¼°       â”‚    â”‚ â€¢ è®¿é—®æ§åˆ¶       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚     Redis       â”‚    â”‚  PostgreSQL     â”‚    â”‚    WebSocket    â”‚
         â”‚   (ç¼“å­˜å±‚)       â”‚    â”‚  (æŒä¹…åŒ–å±‚)      â”‚    â”‚   (å®æ—¶æ¨é€)     â”‚
         â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
         â”‚ â€¢ å®æ—¶æ•°æ®       â”‚    â”‚ â€¢ å†å²æ•°æ®       â”‚    â”‚ â€¢ ä»·æ ¼æ›´æ–°       â”‚
         â”‚ â€¢ çƒ­ç‚¹ç¼“å­˜       â”‚    â”‚ â€¢ ç”¨æˆ·é…ç½®       â”‚    â”‚ â€¢ å¼‚å¸¸å‘Šè­¦       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ’» æ ¸å¿ƒä»£ç å®ç°æŒ‡å—

#### Day 11 ä»»åŠ¡ï¼šåŸºç¡€æ¶æ„æ­å»º

**1. é¡¹ç›®ç»“æ„è®¾è®¡**
```
defi-aggregator/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ collector/           # æ•°æ®æ”¶é›†æœåŠ¡
â”‚   â”œâ”€â”€ processor/           # æ•°æ®å¤„ç†æœåŠ¡
â”‚   â””â”€â”€ gateway/             # APIç½‘å…³æœåŠ¡
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ collector/
â”‚   â”‚   â”œâ”€â”€ ethereum/        # ä»¥å¤ªåŠæ•°æ®æ”¶é›†
â”‚   â”‚   â”œâ”€â”€ uniswap/         # Uniswapåè®®
â”‚   â”‚   â””â”€â”€ compound/        # Compoundåè®®
â”‚   â”œâ”€â”€ processor/
â”‚   â”‚   â”œâ”€â”€ calculator/      # æŒ‡æ ‡è®¡ç®—
â”‚   â”‚   â”œâ”€â”€ analyzer/        # æ•°æ®åˆ†æ
â”‚   â”‚   â””â”€â”€ risk/            # é£é™©è¯„ä¼°
â”‚   â”œâ”€â”€ gateway/
â”‚   â”‚   â”œâ”€â”€ handlers/        # HTTPå¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ middleware/      # ä¸­é—´ä»¶
â”‚   â”‚   â””â”€â”€ websocket/       # WebSocketå¤„ç†
â”‚   â”œâ”€â”€ shared/
â”‚   â”‚   â”œâ”€â”€ models/          # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ database/        # æ•°æ®åº“æ“ä½œ
â”‚   â”‚   â”œâ”€â”€ cache/           # ç¼“å­˜æ“ä½œ
â”‚   â”‚   â””â”€â”€ config/          # é…ç½®ç®¡ç†
â”œâ”€â”€ api/
â”‚   â””â”€â”€ openapi.yaml         # APIè§„èŒƒ
â”œâ”€â”€ deployments/
â”‚   â”œâ”€â”€ docker-compose.yml   # æœ¬åœ°éƒ¨ç½²
â”‚   â””â”€â”€ Dockerfile           # å®¹å™¨æ„å»º
â””â”€â”€ docs/
    â”œâ”€â”€ architecture.md      # æ¶æ„æ–‡æ¡£
    â””â”€â”€ api.md               # APIæ–‡æ¡£
```

**2. åŸºç¡€æ¨¡å‹å®šä¹‰**
```go
// internal/shared/models/defi.go
package models

import (
    "time"
    "github.com/shopspring/decimal"
)

// DeFiåè®®ä¿¡æ¯
type Protocol struct {
    ID          string          `json:"id" db:"id"`
    Name        string          `json:"name" db:"name"`
    Chain       string          `json:"chain" db:"chain"`
    Category    string          `json:"category" db:"category"`
    TVL         decimal.Decimal `json:"tvl" db:"tvl"`
    UpdatedAt   time.Time       `json:"updated_at" db:"updated_at"`
}

// æµåŠ¨æ€§æ± ä¿¡æ¯
type LiquidityPool struct {
    ID           string          `json:"id" db:"id"`
    ProtocolID   string          `json:"protocol_id" db:"protocol_id"`
    Token0       string          `json:"token0" db:"token0"`
    Token1       string          `json:"token1" db:"token1"`
    Reserve0     decimal.Decimal `json:"reserve0" db:"reserve0"`
    Reserve1     decimal.Decimal `json:"reserve1" db:"reserve1"`
    Price0       decimal.Decimal `json:"price0" db:"price0"`
    Price1       decimal.Decimal `json:"price1" db:"price1"`
    Volume24h    decimal.Decimal `json:"volume_24h" db:"volume_24h"`
    Fees24h      decimal.Decimal `json:"fees_24h" db:"fees_24h"`
    APR          decimal.Decimal `json:"apr" db:"apr"`
    UpdatedAt    time.Time       `json:"updated_at" db:"updated_at"`
}

// å€Ÿè´·å¸‚åœºä¿¡æ¯
type LendingMarket struct {
    ID              string          `json:"id" db:"id"`
    ProtocolID      string          `json:"protocol_id" db:"protocol_id"`
    Asset           string          `json:"asset" db:"asset"`
    SupplyAPY       decimal.Decimal `json:"supply_apy" db:"supply_apy"`
    BorrowAPY       decimal.Decimal `json:"borrow_apy" db:"borrow_apy"`
    TotalSupply     decimal.Decimal `json:"total_supply" db:"total_supply"`
    TotalBorrow     decimal.Decimal `json:"total_borrow" db:"total_borrow"`
    UtilizationRate decimal.Decimal `json:"utilization_rate" db:"utilization_rate"`
    UpdatedAt       time.Time       `json:"updated_at" db:"updated_at"`
}
```

**3. æ•°æ®åº“Schemaè®¾è®¡**
```sql
-- migrations/001_initial_schema.sql

-- åè®®è¡¨
CREATE TABLE protocols (
    id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    chain VARCHAR(20) NOT NULL,
    category VARCHAR(50) NOT NULL,
    tvl DECIMAL(20,2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æµåŠ¨æ€§æ± è¡¨
CREATE TABLE liquidity_pools (
    id VARCHAR(100) PRIMARY KEY,
    protocol_id VARCHAR(50) NOT NULL,
    token0 VARCHAR(42) NOT NULL,
    token1 VARCHAR(42) NOT NULL,
    reserve0 DECIMAL(30,18) DEFAULT 0,
    reserve1 DECIMAL(30,18) DEFAULT 0,
    price0 DECIMAL(30,18) DEFAULT 0,
    price1 DECIMAL(30,18) DEFAULT 0,
    volume_24h DECIMAL(20,2) DEFAULT 0,
    fees_24h DECIMAL(20,2) DEFAULT 0,
    apr DECIMAL(8,4) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (protocol_id) REFERENCES protocols(id)
);

-- å€Ÿè´·å¸‚åœºè¡¨
CREATE TABLE lending_markets (
    id VARCHAR(100) PRIMARY KEY,
    protocol_id VARCHAR(50) NOT NULL,
    asset VARCHAR(42) NOT NULL,
    supply_apy DECIMAL(8,4) DEFAULT 0,
    borrow_apy DECIMAL(8,4) DEFAULT 0,
    total_supply DECIMAL(30,18) DEFAULT 0,
    total_borrow DECIMAL(30,18) DEFAULT 0,
    utilization_rate DECIMAL(8,4) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (protocol_id) REFERENCES protocols(id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_pools_protocol ON liquidity_pools(protocol_id);
CREATE INDEX idx_pools_tokens ON liquidity_pools(token0, token1);
CREATE INDEX idx_markets_protocol ON lending_markets(protocol_id);
CREATE INDEX idx_markets_asset ON lending_markets(asset);
```

**4. é…ç½®ç®¡ç†ç³»ç»Ÿ**
```go
// internal/shared/config/config.go
package config

import (
    "os"
    "strconv"
    "github.com/joho/godotenv"
)

type Config struct {
    // æ•°æ®åº“é…ç½®
    Database DatabaseConfig `json:"database"`
    
    // Redisé…ç½®
    Redis RedisConfig `json:"redis"`
    
    // åŒºå—é“¾é…ç½®
    Blockchain BlockchainConfig `json:"blockchain"`
    
    // æœåŠ¡é…ç½®
    Services ServicesConfig `json:"services"`
}

type DatabaseConfig struct {
    Host     string `json:"host"`
    Port     int    `json:"port"`
    Name     string `json:"name"`
    User     string `json:"user"`
    Password string `json:"password"`
    SSLMode  string `json:"ssl_mode"`
}

type RedisConfig struct {
    Host     string `json:"host"`
    Port     int    `json:"port"`
    Password string `json:"password"`
    DB       int    `json:"db"`
}

type BlockchainConfig struct {
    EthereumRPC string `json:"ethereum_rpc"`
    BSCRpc      string `json:"bsc_rpc"`
    PolygonRPC  string `json:"polygon_rpc"`
}

type ServicesConfig struct {
    Collector CollectorConfig `json:"collector"`
    Processor ProcessorConfig `json:"processor"`
    Gateway   GatewayConfig   `json:"gateway"`
}

type CollectorConfig struct {
    Port           int `json:"port"`
    UpdateInterval int `json:"update_interval"` // ç§’
}

type ProcessorConfig struct {
    Port       int `json:"port"`
    BatchSize  int `json:"batch_size"`
    WorkerNum  int `json:"worker_num"`
}

type GatewayConfig struct {
    Port         int    `json:"port"`
    RateLimit    int    `json:"rate_limit"`
    CacheTimeout int    `json:"cache_timeout"`
    JWTSecret    string `json:"jwt_secret"`
}

func Load() (*Config, error) {
    // åŠ è½½.envæ–‡ä»¶
    godotenv.Load()
    
    cfg := &Config{
        Database: DatabaseConfig{
            Host:     getEnv("DB_HOST", "localhost"),
            Port:     getEnvAsInt("DB_PORT", 5432),
            Name:     getEnv("DB_NAME", "defi_aggregator"),
            User:     getEnv("DB_USER", "postgres"),
            Password: getEnv("DB_PASSWORD", ""),
            SSLMode:  getEnv("DB_SSL_MODE", "disable"),
        },
        Redis: RedisConfig{
            Host:     getEnv("REDIS_HOST", "localhost"),
            Port:     getEnvAsInt("REDIS_PORT", 6379),
            Password: getEnv("REDIS_PASSWORD", ""),
            DB:       getEnvAsInt("REDIS_DB", 0),
        },
        Blockchain: BlockchainConfig{
            EthereumRPC: getEnv("ETHEREUM_RPC", "https://mainnet.infura.io/v3/YOUR_KEY"),
            BSCRpc:      getEnv("BSC_RPC", "https://bsc-dataseed.binance.org/"),
            PolygonRPC:  getEnv("POLYGON_RPC", "https://polygon-rpc.com/"),
        },
        Services: ServicesConfig{
            Collector: CollectorConfig{
                Port:           getEnvAsInt("COLLECTOR_PORT", 8001),
                UpdateInterval: getEnvAsInt("UPDATE_INTERVAL", 30),
            },
            Processor: ProcessorConfig{
                Port:      getEnvAsInt("PROCESSOR_PORT", 8002),
                BatchSize: getEnvAsInt("BATCH_SIZE", 100),
                WorkerNum: getEnvAsInt("WORKER_NUM", 10),
            },
            Gateway: GatewayConfig{
                Port:         getEnvAsInt("GATEWAY_PORT", 8000),
                RateLimit:    getEnvAsInt("RATE_LIMIT", 1000),
                CacheTimeout: getEnvAsInt("CACHE_TIMEOUT", 300),
                JWTSecret:    getEnv("JWT_SECRET", "your-secret-key"),
            },
        },
    }
    
    return cfg, nil
}

func getEnv(key, fallback string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return fallback
}

func getEnvAsInt(key string, fallback int) int {
    if value := os.Getenv(key); value != "" {
        if intVal, err := strconv.Atoi(value); err == nil {
            return intVal
        }
    }
    return fallback
}
```

#### Day 12 ä»»åŠ¡ï¼šæ ¸å¿ƒä¸šåŠ¡å®ç°

**1. æ•°æ®æ”¶é›†æœåŠ¡å®ç°**
```go
// internal/collector/ethereum/client.go
package ethereum

import (
    "context"
    "math/big"
    "github.com/ethereum/go-ethereum/ethclient"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/accounts/abi/bind"
)

type Client struct {
    ethClient  *ethclient.Client
    contracts  map[string]common.Address
}

func NewClient(rpcURL string) (*Client, error) {
    client, err := ethclient.Dial(rpcURL)
    if err != nil {
        return nil, err
    }
    
    contracts := map[string]common.Address{
        "uniswap_factory": common.HexToAddress("0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f"),
        "compound_comptroller": common.HexToAddress("0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B"),
        // æ›´å¤šåˆçº¦åœ°å€...
    }
    
    return &Client{
        ethClient: client,
        contracts: contracts,
    }, nil
}

func (c *Client) GetBlockNumber() (*big.Int, error) {
    return c.ethClient.BlockNumber(context.Background())
}

func (c *Client) GetPairReserves(pairAddress common.Address) (*big.Int, *big.Int, error) {
    // å®ç°Uniswap pairåˆçº¦è°ƒç”¨
    // è¿™é‡Œéœ€è¦ç”Ÿæˆåˆçº¦ABIç»‘å®š
    
    // ç¤ºä¾‹ï¼šè°ƒç”¨getReservesæ–¹æ³•
    caller := bind.CallOpts{}
    
    // å®é™…å®ç°éœ€è¦åˆçº¦ABIç»‘å®š
    // reserve0, reserve1, timestamp, err := pairContract.GetReserves(&caller)
    
    // ä¸´æ—¶è¿”å›ç¤ºä¾‹æ•°æ®
    return big.NewInt(1000000), big.NewInt(2000000), nil
}
```

**2. æ•°æ®å¤„ç†æœåŠ¡å®ç°**
```go
// internal/processor/calculator/apy.go
package calculator

import (
    "math"
    "github.com/shopspring/decimal"
)

type APYCalculator struct{}

func NewAPYCalculator() *APYCalculator {
    return &APYCalculator{}
}

// è®¡ç®—Uniswap LPçš„APY
func (c *APYCalculator) CalculateUniswapAPY(
    volume24h decimal.Decimal,
    tvl decimal.Decimal,
    feeRate decimal.Decimal,
) decimal.Decimal {
    if tvl.IsZero() {
        return decimal.Zero
    }
    
    // æ—¥æ”¶ç›Šç‡ = (24å°æ—¶äº¤æ˜“é‡ * æ‰‹ç»­è´¹ç‡) / TVL
    dailyReturn := volume24h.Mul(feeRate).Div(tvl)
    
    // å¹´åŒ–æ”¶ç›Šç‡ = (1 + æ—¥æ”¶ç›Šç‡)^365 - 1
    dailyReturnFloat, _ := dailyReturn.Float64()
    apy := math.Pow(1+dailyReturnFloat, 365) - 1
    
    return decimal.NewFromFloat(apy)
}

// è®¡ç®—å¤åˆæ”¶ç›ŠAPY
func (c *APYCalculator) CalculateCompoundAPY(
    apr decimal.Decimal,
    compoundFrequency int, // æ¯å¹´å¤æŠ•æ¬¡æ•°
) decimal.Decimal {
    aprFloat, _ := apr.Float64()
    freq := float64(compoundFrequency)
    
    // APY = (1 + APR/n)^n - 1
    apy := math.Pow(1+aprFloat/freq, freq) - 1
    
    return decimal.NewFromFloat(apy)
}

// è®¡ç®—æµåŠ¨æ€§æŒ–çŸ¿æ”¶ç›Š
func (c *APYCalculator) CalculateFarmingAPY(
    rewardPerSecond decimal.Decimal,
    rewardTokenPrice decimal.Decimal,
    totalStaked decimal.Decimal,
    stakedTokenPrice decimal.Decimal,
) decimal.Decimal {
    if totalStaked.IsZero() {
        return decimal.Zero
    }
    
    // å¹´æ”¶ç›Š = æ¯ç§’å¥–åŠ± * ç§’/å¹´ * å¥–åŠ±ä»£å¸ä»·æ ¼
    secondsPerYear := decimal.NewFromInt(365 * 24 * 3600)
    yearlyRewardValue := rewardPerSecond.Mul(secondsPerYear).Mul(rewardTokenPrice)
    
    // æ€»è´¨æŠ¼ä»·å€¼
    totalStakedValue := totalStaked.Mul(stakedTokenPrice)
    
    // APY = å¹´æ”¶ç›Š / æ€»è´¨æŠ¼ä»·å€¼
    return yearlyRewardValue.Div(totalStakedValue)
}
```

**3. APIç½‘å…³å®ç°**
```go
// internal/gateway/handlers/defi.go
package handlers

import (
    "net/http"
    "strconv"
    "github.com/gin-gonic/gin"
    "github.com/your-project/internal/shared/models"
    "github.com/your-project/internal/shared/database"
)

type DeFiHandler struct {
    db *database.DB
}

func NewDeFiHandler(db *database.DB) *DeFiHandler {
    return &DeFiHandler{db: db}
}

// è·å–åè®®åˆ—è¡¨
func (h *DeFiHandler) GetProtocols(c *gin.Context) {
    // è§£ææŸ¥è¯¢å‚æ•°
    chain := c.Query("chain")
    category := c.Query("category")
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
    offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
    
    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    query := h.db.Model(&models.Protocol{})
    if chain != "" {
        query = query.Where("chain = ?", chain)
    }
    if category != "" {
        query = query.Where("category = ?", category)
    }
    
    // æ‰§è¡ŒæŸ¥è¯¢
    var protocols []models.Protocol
    var total int64
    
    query.Count(&total)
    err := query.Limit(limit).Offset(offset).
        Order("tvl DESC").Find(&protocols).Error
    
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to fetch protocols",
        })
        return
    }
    
    // è¿”å›ç»“æœ
    c.JSON(http.StatusOK, gin.H{
        "data": protocols,
        "pagination": gin.H{
            "total":  total,
            "limit":  limit,
            "offset": offset,
        },
    })
}

// è·å–æµåŠ¨æ€§æ± åˆ—è¡¨
func (h *DeFiHandler) GetLiquidityPools(c *gin.Context) {
    protocolID := c.Query("protocol_id")
    token := c.Query("token")
    sortBy := c.DefaultQuery("sort_by", "tvl")
    order := c.DefaultQuery("order", "desc")
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
    offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
    
    query := h.db.Model(&models.LiquidityPool{})
    
    if protocolID != "" {
        query = query.Where("protocol_id = ?", protocolID)
    }
    
    if token != "" {
        query = query.Where("token0 = ? OR token1 = ?", token, token)
    }
    
    // æ„å»ºæ’åº
    orderBy := sortBy + " " + order
    
    var pools []models.LiquidityPool
    var total int64
    
    query.Count(&total)
    err := query.Limit(limit).Offset(offset).
        Order(orderBy).Find(&pools).Error
    
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to fetch liquidity pools",
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "data": pools,
        "pagination": gin.H{
            "total":  total,
            "limit":  limit,
            "offset": offset,
        },
    })
}

// è·å–æœ€ä¼˜æ”¶ç›Šç‡
func (h *DeFiHandler) GetBestYields(c *gin.Context) {
    asset := c.Query("asset")
    minAmount := c.Query("min_amount")
    riskLevel := c.DefaultQuery("risk_level", "medium")
    
    // æ„å»ºå¤æ‚æŸ¥è¯¢ï¼Œæ‰¾å‡ºæœ€ä¼˜æ”¶ç›Šç‡
    var results []struct {
        models.LendingMarket
        ProtocolName string `json:"protocol_name"`
        RiskScore    int    `json:"risk_score"`
    }
    
    query := `
        SELECT lm.*, p.name as protocol_name, 
               CASE 
                   WHEN p.category = 'blue-chip' THEN 1
                   WHEN p.category = 'established' THEN 2
                   ELSE 3
               END as risk_score
        FROM lending_markets lm
        JOIN protocols p ON lm.protocol_id = p.id
        WHERE 1=1
    `
    
    params := []interface{}{}
    
    if asset != "" {
        query += " AND lm.asset = ?"
        params = append(params, asset)
    }
    
    if minAmount != "" {
        query += " AND lm.total_supply >= ?"
        params = append(params, minAmount)
    }
    
    switch riskLevel {
    case "low":
        query += " AND risk_score = 1"
    case "medium":
        query += " AND risk_score <= 2"
    case "high":
        // åŒ…å«æ‰€æœ‰é£é™©ç­‰çº§
    }
    
    query += " ORDER BY lm.supply_apy DESC LIMIT 10"
    
    err := h.db.Raw(query, params...).Scan(&results).Error
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to fetch best yields",
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "data": results,
    })
}
```

**4. Dockeréƒ¨ç½²é…ç½®**
```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: defi_aggregator
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

  collector:
    build: 
      context: .
      target: collector
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
      - ETHEREUM_RPC=${ETHEREUM_RPC}
    depends_on:
      - postgres
      - redis
    ports:
      - "8001:8001"

  processor:
    build: 
      context: .
      target: processor
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      - postgres
      - redis
    ports:
      - "8002:8002"

  gateway:
    build: 
      context: .
      target: gateway
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      - postgres
      - redis
    ports:
      - "8000:8000"

volumes:
  postgres_data:
  redis_data:
```

```dockerfile
# Dockerfile
FROM golang:1.19-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .

# æ„å»ºæ”¶é›†å™¨æœåŠ¡
FROM builder AS collector-build
RUN go build -o collector ./cmd/collector

# æ„å»ºå¤„ç†å™¨æœåŠ¡
FROM builder AS processor-build
RUN go build -o processor ./cmd/processor

# æ„å»ºç½‘å…³æœåŠ¡
FROM builder AS gateway-build
RUN go build -o gateway ./cmd/gateway

# æ”¶é›†å™¨è¿è¡Œæ—¶
FROM alpine:latest AS collector
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=collector-build /app/collector .
CMD ["./collector"]

# å¤„ç†å™¨è¿è¡Œæ—¶
FROM alpine:latest AS processor
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=processor-build /app/processor .
CMD ["./processor"]

# ç½‘å…³è¿è¡Œæ—¶
FROM alpine:latest AS gateway
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=gateway-build /app/gateway .
CMD ["./gateway"]
```

---

## ğŸ”¥ é¡¹ç›®2ï¼šWeb3äº¤æ˜“ç›‘æ§ç³»ç»Ÿ (Day 13-14)

### ğŸ“‹ é¡¹ç›®æ¦‚è¿°
**é¡¹ç›®åç§°**: Web3 Transaction Monitor
**æ ¸å¿ƒä»·å€¼**: å®æ—¶ç›‘æ§åŒºå—é“¾å¤§é¢äº¤æ˜“å’Œå¼‚å¸¸è¡Œä¸ºï¼Œæä¾›æ™ºèƒ½å‘Šè­¦
**æŠ€æœ¯äº®ç‚¹**: äº‹ä»¶é©±åŠ¨æ¶æ„ + gRPCå¾®æœåŠ¡ + å®æ—¶WebSocketæ¨é€

### ğŸ¯ åŠŸèƒ½éœ€æ±‚è¯¦ç»†å®šä¹‰
```yaml
æ ¸å¿ƒåŠŸèƒ½æ¨¡å—:
  1. äº¤æ˜“ç›‘å¬æœåŠ¡:
     - å¤šé“¾äº¤æ˜“å®æ—¶ç›‘å¬
     - æ™ºèƒ½åˆçº¦äº‹ä»¶ç›‘å¬
     - å¤§é¢äº¤æ˜“è‡ªåŠ¨è¯†åˆ«
     - MEVäº¤æ˜“æ£€æµ‹

  2. åˆ†æå¼•æ“æœåŠ¡:
     - äº¤æ˜“æ¨¡å¼è¯†åˆ«
     - å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
     - åœ°å€æ ‡ç­¾å’Œåˆ†ç±»
     - é£é™©è¯„ä¼°ç®—æ³•

  3. é€šçŸ¥æ¨é€æœåŠ¡:
     - å®æ—¶WebSocketæ¨é€
     - é‚®ä»¶/çŸ­ä¿¡å‘Šè­¦
     - Webhooké›†æˆ
     - å‘Šè­¦è§„åˆ™é…ç½®

  4. æ•°æ®å­˜å‚¨æœåŠ¡:
     - äº¤æ˜“æ•°æ®å­˜å‚¨
     - åœ°å€æ ‡ç­¾ç®¡ç†
     - å‘Šè­¦å†å²è®°å½•
     - ç”¨æˆ·é…ç½®å­˜å‚¨
```

### ğŸ’» æ ¸å¿ƒä»£ç å®ç°æŒ‡å—

#### Day 13 ä»»åŠ¡ï¼šç›‘å¬å’Œåˆ†æ

**1. äº¤æ˜“ç›‘å¬æœåŠ¡**
```go
// internal/monitor/listener/ethereum.go
package listener

import (
    "context"
    "log"
    "math/big"
    "github.com/ethereum/go-ethereum"
    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/ethclient"
    "github.com/ethereum/go-ethereum/common"
)

type EthereumListener struct {
    client      *ethclient.Client
    subscribers []TransactionSubscriber
    threshold   *big.Int // å¤§é¢äº¤æ˜“é˜ˆå€¼
}

type TransactionSubscriber interface {
    OnTransaction(tx *Transaction) error
}

type Transaction struct {
    Hash        string          `json:"hash"`
    From        string          `json:"from"`
    To          string          `json:"to"`
    Value       *big.Int        `json:"value"`
    GasPrice    *big.Int        `json:"gas_price"`
    GasUsed     uint64          `json:"gas_used"`
    BlockNumber uint64          `json:"block_number"`
    Timestamp   int64           `json:"timestamp"`
    Status      uint64          `json:"status"`
    IsLarge     bool            `json:"is_large"`
    Category    string          `json:"category"`
}

func NewEthereumListener(rpcURL string, thresholdETH float64) (*EthereumListener, error) {
    client, err := ethclient.Dial(rpcURL)
    if err != nil {
        return nil, err
    }
    
    // å°†ETHè½¬æ¢ä¸ºWei
    thresholdWei := new(big.Int)
    thresholdWei.SetString(fmt.Sprintf("%.0f", thresholdETH*1e18), 10)
    
    return &EthereumListener{
        client:      client,
        subscribers: make([]TransactionSubscriber, 0),
        threshold:   thresholdWei,
    }, nil
}

func (l *EthereumListener) Subscribe(subscriber TransactionSubscriber) {
    l.subscribers = append(l.subscribers, subscriber)
}

func (l *EthereumListener) Start(ctx context.Context) error {
    headers := make(chan *types.Header)
    
    sub, err := l.client.SubscribeNewHead(ctx, headers)
    if err != nil {
        return err
    }
    
    defer sub.Unsubscribe()
    
    for {
        select {
        case err := <-sub.Err():
            log.Printf("Subscription error: %v", err)
            return err
        case header := <-headers:
            if err := l.processBlock(ctx, header.Number); err != nil {
                log.Printf("Error processing block %d: %v", header.Number, err)
            }
        case <-ctx.Done():
            return ctx.Err()
        }
    }
}

func (l *EthereumListener) processBlock(ctx context.Context, blockNumber *big.Int) error {
    block, err := l.client.BlockByNumber(ctx, blockNumber)
    if err != nil {
        return err
    }
    
    for _, tx := range block.Transactions() {
        transaction := l.convertTransaction(tx, block)
        
        // åˆ†æäº¤æ˜“ç±»å‹
        transaction.Category = l.analyzeTransactionCategory(transaction)
        transaction.IsLarge = transaction.Value.Cmp(l.threshold) > 0
        
        // é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…
        for _, subscriber := range l.subscribers {
            if err := subscriber.OnTransaction(transaction); err != nil {
                log.Printf("Subscriber error: %v", err)
            }
        }
    }
    
    return nil
}

func (l *EthereumListener) convertTransaction(tx *types.Transaction, block *types.Block) *Transaction {
    var to string
    if tx.To() != nil {
        to = tx.To().Hex()
    }
    
    return &Transaction{
        Hash:        tx.Hash().Hex(),
        From:        l.getFromAddress(tx),
        To:          to,
        Value:       tx.Value(),
        GasPrice:    tx.GasPrice(),
        BlockNumber: block.NumberU64(),
        Timestamp:   int64(block.Time()),
    }
}

func (l *EthereumListener) analyzeTransactionCategory(tx *Transaction) string {
    // ç®€å•çš„äº¤æ˜“ç±»å‹åˆ†æ
    if tx.To == "" {
        return "contract_creation"
    }
    
    if tx.Value.Cmp(big.NewInt(0)) == 0 {
        return "contract_interaction"
    }
    
    if tx.Value.Cmp(l.threshold) > 0 {
        return "large_transfer"
    }
    
    return "normal_transfer"
}
```

**2. å¼‚å¸¸æ£€æµ‹å¼•æ“**
```go
// internal/analyzer/anomaly/detector.go
package anomaly

import (
    "math/big"
    "time"
    "github.com/your-project/internal/shared/models"
)

type AnomalyDetector struct {
    addressTracker map[string]*AddressActivity
    patterns       []Pattern
}

type AddressActivity struct {
    Address           string
    TotalVolume       *big.Int
    TransactionCount  int
    LastActivityTime  time.Time
    DailyVolume       *big.Int
    DailyTxCount      int
    UnusualPatterns   []string
}

type Pattern interface {
    Detect(activity *AddressActivity, tx *Transaction) []Anomaly
}

type Anomaly struct {
    Type        string    `json:"type"`
    Severity    string    `json:"severity"`
    Description string    `json:"description"`
    Address     string    `json:"address"`
    Transaction string    `json:"transaction"`
    Timestamp   time.Time `json:"timestamp"`
    Score       float64   `json:"score"`
}

// é«˜é¢‘äº¤æ˜“æ£€æµ‹
type HighFrequencyPattern struct {
    timeWindow    time.Duration
    txThreshold   int
    volumeThreshold *big.Int
}

func (p *HighFrequencyPattern) Detect(activity *AddressActivity, tx *Transaction) []Anomaly {
    var anomalies []Anomaly
    
    // æ£€æŸ¥æ˜¯å¦åœ¨çŸ­æ—¶é—´å†…æœ‰å¤§é‡äº¤æ˜“
    if activity.DailyTxCount > p.txThreshold {
        anomalies = append(anomalies, Anomaly{
            Type:        "high_frequency",
            Severity:    "medium",
            Description: fmt.Sprintf("Address has %d transactions in 24h", activity.DailyTxCount),
            Address:     activity.Address,
            Transaction: tx.Hash,
            Timestamp:   time.Now(),
            Score:       float64(activity.DailyTxCount) / float64(p.txThreshold),
        })
    }
    
    return anomalies
}

// å¼‚å¸¸é‡‘é¢æ£€æµ‹
type UnusualAmountPattern struct {
    historicalAverage map[string]*big.Int
    deviationFactor   float64
}

func (p *UnusualAmountPattern) Detect(activity *AddressActivity, tx *Transaction) []Anomaly {
    var anomalies []Anomaly
    
    avgAmount := p.historicalAverage[activity.Address]
    if avgAmount == nil {
        return anomalies
    }
    
    // è®¡ç®—å½“å‰äº¤æ˜“é‡‘é¢ä¸å†å²å¹³å‡çš„åå·®
    deviation := new(big.Float).Quo(
        new(big.Float).SetInt(tx.Value),
        new(big.Float).SetInt(avgAmount),
    )
    
    deviationFloat, _ := deviation.Float64()
    
    if deviationFloat > p.deviationFactor {
        anomalies = append(anomalies, Anomaly{
            Type:        "unusual_amount",
            Severity:    "high",
            Description: fmt.Sprintf("Transaction amount %.2fx larger than average", deviationFloat),
            Address:     activity.Address,
            Transaction: tx.Hash,
            Timestamp:   time.Now(),
            Score:       deviationFloat / p.deviationFactor,
        })
    }
    
    return anomalies
}

// æ´—é’±æ¨¡å¼æ£€æµ‹
type MoneyLaunderingPattern struct {
    hopLimit int
    timeWindow time.Duration
}

func (p *MoneyLaunderingPattern) Detect(activity *AddressActivity, tx *Transaction) []Anomaly {
    // æ£€æµ‹èµ„é‡‘å¿«é€Ÿæµè½¬æ¨¡å¼
    // è¿™éœ€è¦å›¾æ•°æ®åº“æˆ–æ›´å¤æ‚çš„æ•°æ®ç»“æ„æ¥è¿½è¸ªèµ„é‡‘æµ
    
    // ç®€åŒ–ç‰ˆæœ¬ï¼šæ£€æµ‹çŸ­æ—¶é—´å†…çš„å¤šè·³è½¬è´¦
    var anomalies []Anomaly
    
    // å®é™…å®ç°éœ€è¦è¿½è¸ªäº¤æ˜“é“¾
    
    return anomalies
}
```

#### Day 14 ä»»åŠ¡ï¼šé€šçŸ¥å’Œå±•ç¤º

**1. WebSocketæ¨é€æœåŠ¡**
```go
// internal/notification/websocket/hub.go
package websocket

import (
    "encoding/json"
    "log"
    "net/http"
    "github.com/gorilla/websocket"
    "github.com/gin-gonic/gin"
)

type Hub struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

type Client struct {
    hub    *Hub
    conn   *websocket.Conn
    send   chan []byte
    userID string
    filters ClientFilters
}

type ClientFilters struct {
    MinAmount    string   `json:"min_amount"`
    Addresses    []string `json:"addresses"`
    Tokens       []string `json:"tokens"`
    AnomalyTypes []string `json:"anomaly_types"`
}

type Message struct {
    Type      string      `json:"type"`
    Data      interface{} `json:"data"`
    Timestamp int64       `json:"timestamp"`
}

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true // ç”Ÿäº§ç¯å¢ƒéœ€è¦æ›´ä¸¥æ ¼çš„æ£€æŸ¥
    },
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.clients[client] = true
            log.Printf("Client registered: %s", client.userID)
            
        case client := <-h.unregister:
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
                log.Printf("Client unregistered: %s", client.userID)
            }
            
        case message := <-h.broadcast:
            for client := range h.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(h.clients, client)
                }
            }
        }
    }
}

func (h *Hub) BroadcastTransaction(tx *Transaction) {
    message := Message{
        Type:      "transaction",
        Data:      tx,
        Timestamp: time.Now().Unix(),
    }
    
    h.broadcastToFilteredClients(message, func(client *Client) bool {
        return h.matchesTransactionFilter(client.filters, tx)
    })
}

func (h *Hub) BroadcastAnomaly(anomaly *Anomaly) {
    message := Message{
        Type:      "anomaly",
        Data:      anomaly,
        Timestamp: time.Now().Unix(),
    }
    
    h.broadcastToFilteredClients(message, func(client *Client) bool {
        return h.matchesAnomalyFilter(client.filters, anomaly)
    })
}

func (h *Hub) broadcastToFilteredClients(message Message, filter func(*Client) bool) {
    data, err := json.Marshal(message)
    if err != nil {
        log.Printf("Error marshaling message: %v", err)
        return
    }
    
    for client := range h.clients {
        if filter(client) {
            select {
            case client.send <- data:
            default:
                close(client.send)
                delete(h.clients, client)
            }
        }
    }
}

func (h *Hub) HandleWebSocket(c *gin.Context) {
    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        log.Printf("WebSocket upgrade error: %v", err)
        return
    }
    
    userID := c.Query("user_id")
    if userID == "" {
        userID = "anonymous"
    }
    
    client := &Client{
        hub:    h,
        conn:   conn,
        send:   make(chan []byte, 256),
        userID: userID,
    }
    
    client.hub.register <- client
    
    go client.writePump()
    go client.readPump()
}

func (c *Client) readPump() {
    defer func() {
        c.hub.unregister <- c
        c.conn.Close()
    }()
    
    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            break
        }
        
        // å¤„ç†å®¢æˆ·ç«¯å‘é€çš„è¿‡æ»¤æ¡ä»¶æ›´æ–°
        var filterUpdate ClientFilters
        if err := json.Unmarshal(message, &filterUpdate); err == nil {
            c.filters = filterUpdate
            log.Printf("Updated filters for client %s", c.userID)
        }
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()
    
    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            
            if err := c.conn.WriteMessage(websocket.TextMessage, message); err != nil {
                return
            }
        }
    }
}
```

**2. gRPCæœåŠ¡é€šä¿¡**
```protobuf
// api/proto/monitor.proto
syntax = "proto3";

package monitor;

option go_package = "./pb";

service MonitorService {
    rpc SubscribeTransactions(TransactionFilter) returns (stream TransactionEvent);
    rpc SubscribeAnomalies(AnomalyFilter) returns (stream AnomalyEvent);
    rpc GetAddressAnalysis(AddressRequest) returns (AddressAnalysis);
    rpc UpdateAlertRules(AlertRules) returns (UpdateResponse);
}

message TransactionFilter {
    repeated string addresses = 1;
    string min_amount = 2;
    repeated string tokens = 3;
    repeated string categories = 4;
}

message AnomalyFilter {
    repeated string types = 1;
    string min_severity = 2;
    repeated string addresses = 3;
}

message TransactionEvent {
    string hash = 1;
    string from_address = 2;
    string to_address = 3;
    string value = 4;
    uint64 block_number = 5;
    int64 timestamp = 6;
    string category = 7;
    bool is_large = 8;
}

message AnomalyEvent {
    string type = 1;
    string severity = 2;
    string description = 3;
    string address = 4;
    string transaction = 5;
    int64 timestamp = 6;
    double score = 7;
}

message AddressRequest {
    string address = 1;
    int32 days = 2;
}

message AddressAnalysis {
    string address = 1;
    string total_volume = 2;
    int32 transaction_count = 3;
    repeated string labels = 4;
    double risk_score = 5;
    repeated AnomalyEvent anomalies = 6;
}

message AlertRules {
    string user_id = 1;
    repeated AlertRule rules = 2;
}

message AlertRule {
    string name = 1;
    TransactionFilter transaction_filter = 2;
    AnomalyFilter anomaly_filter = 3;
    repeated string notification_channels = 4;
    bool enabled = 5;
}

message UpdateResponse {
    bool success = 1;
    string message = 2;
}
```

---

## ğŸš€ é¡¹ç›®3ï¼šNFTæ•°æ®åˆ†æå™¨ (Day 15)

### ğŸ“‹ é¡¹ç›®æ¦‚è¿° (å¿«é€Ÿå¼€å‘æ¨¡å¼)
**é¡¹ç›®åç§°**: NFT Market Analyzer
**æ ¸å¿ƒä»·å€¼**: NFTå¸‚åœºæ•°æ®åˆ†æå’Œç¨€æœ‰åº¦è¯„ä¼°
**æŠ€æœ¯äº®ç‚¹**: GraphQL API + æ—¶åºæ•°æ®å¤„ç† + å¤æ‚ç®—æ³•å®ç°

### ğŸ’» æ ¸å¿ƒåŠŸèƒ½å®ç° (ä¸€å¤©å®Œæˆ)

**1. NFTæ•°æ®æ¨¡å‹**
```go
// internal/nft/models/nft.go
package models

type NFTCollection struct {
    Address     string  `json:"address"`
    Name        string  `json:"name"`
    Symbol      string  `json:"symbol"`
    TotalSupply int     `json:"total_supply"`
    FloorPrice  float64 `json:"floor_price"`
    Volume24h   float64 `json:"volume_24h"`
    Owners      int     `json:"owners"`
}

type NFT struct {
    TokenID      string                 `json:"token_id"`
    Collection   string                 `json:"collection"`
    Name         string                 `json:"name"`
    Description  string                 `json:"description"`
    Image        string                 `json:"image"`
    Attributes   []NFTAttribute         `json:"attributes"`
    Rarity       RarityScore           `json:"rarity"`
    PriceHistory []PricePoint          `json:"price_history"`
}

type NFTAttribute struct {
    TraitType string `json:"trait_type"`
    Value     string `json:"value"`
    Rarity    float64 `json:"rarity"` // 0-1ï¼Œè¶Šå°è¶Šç¨€æœ‰
}

type RarityScore struct {
    Rank         int     `json:"rank"`
    Score        float64 `json:"score"`
    Percentile   float64 `json:"percentile"`
    Method       string  `json:"method"`
}
```

**2. ç¨€æœ‰åº¦è®¡ç®—ç®—æ³•**
```go
// internal/nft/rarity/calculator.go
package rarity

import (
    "math"
    "sort"
)

type RarityCalculator struct {
    method string
}

func NewRarityCalculator(method string) *RarityCalculator {
    return &RarityCalculator{method: method}
}

// ç»Ÿè®¡ç¨€æœ‰åº¦è®¡ç®—æ³•
func (r *RarityCalculator) CalculateStatisticalRarity(nfts []NFT) {
    // 1. ç»Ÿè®¡æ¯ä¸ªå±æ€§å€¼çš„å‡ºç°é¢‘ç‡
    traitCounts := make(map[string]map[string]int)
    
    for _, nft := range nfts {
        for _, attr := range nft.Attributes {
            if traitCounts[attr.TraitType] == nil {
                traitCounts[attr.TraitType] = make(map[string]int)
            }
            traitCounts[attr.TraitType][attr.Value]++
        }
    }
    
    // 2. è®¡ç®—æ¯ä¸ªNFTçš„ç¨€æœ‰åº¦åˆ†æ•°
    for i := range nfts {
        score := 0.0
        
        for _, attr := range nfts[i].Attributes {
            traitTotal := 0
            for _, count := range traitCounts[attr.TraitType] {
                traitTotal += count
            }
            
            frequency := float64(traitCounts[attr.TraitType][attr.Value]) / float64(traitTotal)
            nfts[i].Attributes[j].Rarity = frequency
            
            // ä½¿ç”¨å€’æ•°è®¡ç®—ç¨€æœ‰åº¦åˆ†æ•°
            score += 1.0 / frequency
        }
        
        nfts[i].Rarity.Score = score
        nfts[i].Rarity.Method = "statistical"
    }
    
    // 3. æ’åºå¹¶åˆ†é…æ’å
    sort.Slice(nfts, func(i, j int) bool {
        return nfts[i].Rarity.Score > nfts[j].Rarity.Score
    })
    
    for i := range nfts {
        nfts[i].Rarity.Rank = i + 1
        nfts[i].Rarity.Percentile = float64(i+1) / float64(len(nfts)) * 100
    }
}

// ä¿¡æ¯è®ºç¨€æœ‰åº¦è®¡ç®—æ³•
func (r *RarityCalculator) CalculateInformationRarity(nfts []NFT) {
    traitCounts := make(map[string]map[string]int)
    totalSupply := len(nfts)
    
    // ç»Ÿè®¡é¢‘ç‡
    for _, nft := range nfts {
        for _, attr := range nft.Attributes {
            if traitCounts[attr.TraitType] == nil {
                traitCounts[attr.TraitType] = make(map[string]int)
            }
            traitCounts[attr.TraitType][attr.Value]++
        }
    }
    
    // è®¡ç®—ä¿¡æ¯ç†µ
    for i := range nfts {
        entropy := 0.0
        
        for _, attr := range nfts[i].Attributes {
            probability := float64(traitCounts[attr.TraitType][attr.Value]) / float64(totalSupply)
            
            if probability > 0 {
                entropy -= probability * math.Log2(probability)
            }
        }
        
        nfts[i].Rarity.Score = entropy
        nfts[i].Rarity.Method = "information_theory"
    }
}
```

**3. GraphQL Schemaå’ŒResolver**
```graphql
# api/graphql/schema.graphql
type Query {
    collection(address: String!): NFTCollection
    collections(limit: Int, offset: Int, sortBy: String): [NFTCollection!]!
    nft(collection: String!, tokenId: String!): NFT
    nfts(collection: String!, filter: NFTFilter): [NFT!]!
    rarityRanking(collection: String!, method: String): [NFT!]!
    priceAnalysis(collection: String!, period: String): PriceAnalysis
}

type Mutation {
    refreshCollection(address: String!): Boolean
    updateRarityScores(collection: String!, method: String): Boolean
}

type Subscription {
    priceUpdates(collection: String!): PriceUpdate
    newListings(collection: String!): NFTListing
}

input NFTFilter {
    minPrice: Float
    maxPrice: Float
    attributes: [AttributeFilter!]
    rarityRange: RarityRange
}

input AttributeFilter {
    traitType: String!
    values: [String!]!
}

input RarityRange {
    minRank: Int
    maxRank: Int
    minPercentile: Float
    maxPercentile: Float
}

type PriceAnalysis {
    collection: String!
    period: String!
    floorPrice: Float!
    averagePrice: Float!
    volume: Float!
    sales: Int!
    priceChanges: [PriceChange!]!
    volatility: Float!
}

type PriceChange {
    timestamp: Int!
    price: Float!
    volume: Float!
}
```

```go
// internal/nft/graphql/resolver.go
package graphql

import (
    "context"
    "github.com/your-project/internal/nft/models"
    "github.com/your-project/internal/nft/service"
)

type Resolver struct {
    nftService *service.NFTService
}

func (r *queryResolver) Collection(ctx context.Context, address string) (*models.NFTCollection, error) {
    return r.nftService.GetCollection(address)
}

func (r *queryResolver) RarityRanking(ctx context.Context, collection string, method *string) ([]*models.NFT, error) {
    if method == nil {
        defaultMethod := "statistical"
        method = &defaultMethod
    }
    
    return r.nftService.GetRarityRanking(collection, *method)
}

func (r *queryResolver) PriceAnalysis(ctx context.Context, collection string, period string) (*models.PriceAnalysis, error) {
    return r.nftService.GetPriceAnalysis(collection, period)
}

func (r *mutationResolver) UpdateRarityScores(ctx context.Context, collection string, method string) (bool, error) {
    return r.nftService.UpdateRarityScores(collection, method)
}
```

---

## ğŸ¯ æœ€ç»ˆé¡¹ç›®éªŒæ”¶å’Œé¢è¯•å‡†å¤‡

### âœ… é¡¹ç›®å®Œæ•´æ€§æ£€æŸ¥æ¸…å•

**æŠ€æœ¯å®ç°éªŒæ”¶**
- [ ] æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½å®Œæ•´å®ç°
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°80%+
- [ ] APIæ–‡æ¡£å®Œæ•´å‡†ç¡®
- [ ] Dockerå®¹å™¨åŒ–éƒ¨ç½²æˆåŠŸ
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡åŸºå‡†
- [ ] é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µè¦†ç›–
- [ ] ä»£ç è´¨é‡ç¬¦åˆGoæœ€ä½³å®è·µ
- [ ] å®‰å…¨æ€§æ£€æŸ¥é€šè¿‡

**æ–‡æ¡£å’Œå±•ç¤ºå‡†å¤‡**
- [ ] READMEæ–‡æ¡£è¯¦ç»†å®Œæ•´
- [ ] APIæ–‡æ¡£è‡ªåŠ¨ç”Ÿæˆ
- [ ] æ¶æ„å›¾å’Œæµç¨‹å›¾åˆ¶ä½œ
- [ ] éƒ¨ç½²æŒ‡å—ä¸€é”®æ‰§è¡Œ
- [ ] æ¼”ç¤ºè„šæœ¬å‡†å¤‡å®Œæ¯•
- [ ] æŠ€æœ¯éš¾ç‚¹æ€»ç»“æ–‡æ¡£
- [ ] æ”¹è¿›æ–¹æ¡ˆå’Œæ‰©å±•è®¡åˆ’
- [ ] å•†ä¸šä»·å€¼å’Œåº”ç”¨åœºæ™¯è¯´æ˜

**é¢è¯•ææ–™å‡†å¤‡**
- [ ] é¡¹ç›®ä»‹ç»PPT (5-10åˆ†é’Ÿ)
- [ ] ä»£ç æ¼”ç¤ºç¯å¢ƒå‡†å¤‡
- [ ] æŠ€æœ¯é—®é¢˜ç­”æ¡ˆæ•´ç†
- [ ] é¡¹ç›®ä¼˜ç¼ºç‚¹åˆ†æ
- [ ] å›¢é˜Ÿåä½œç»éªŒæ€»ç»“
- [ ] å­¦ä¹ æˆé•¿å¿ƒå¾—å‡†å¤‡

### ğŸ† æˆåŠŸæ ‡å‡†æœ€ç»ˆç¡®è®¤

**90%+è½¬æ­£æˆåŠŸç‡æŒ‡æ ‡:**
1. **æŠ€æœ¯æ·±åº¦å±•ç¤º** (40%æƒé‡)
   - å¾®æœåŠ¡æ¶æ„è®¾è®¡åˆç†
   - Web3ä¸šåŠ¡ç†è§£æ·±å…¥
   - Goè¯­è¨€ä½¿ç”¨ç†Ÿç»ƒ
   - é—®é¢˜è§£å†³èƒ½åŠ›å¼º

2. **é¡¹ç›®å®Œæ•´åº¦** (25%æƒé‡)
   - 3ä¸ªé¡¹ç›®åŠŸèƒ½å®Œæ•´
   - ä»£ç è´¨é‡ä¼˜ç§€
   - éƒ¨ç½²è¿è¡Œç¨³å®š
   - æ–‡æ¡£å®Œæ•´æ¸…æ™°

3. **å­¦ä¹ æˆé•¿ä½“ç°** (20%æƒé‡)
   - 20å¤©å­¦ä¹ æˆæœæ˜¾è‘—
   - æŠ€æœ¯æ ˆå¿«é€ŸæŒæ¡
   - ä¸»åŠ¨å­¦ä¹ èƒ½åŠ›å¼º
   - é€‚åº”èƒ½åŠ›ä¼˜ç§€

4. **æ²Ÿé€šè¡¨è¾¾èƒ½åŠ›** (10%æƒé‡)
   - æŠ€æœ¯è¡¨è¾¾æ¸…æ™°
   - é¡¹ç›®ä»‹ç»é€»è¾‘
   - é—®é¢˜å›ç­”å‡†ç¡®
   - å›¢é˜Ÿåä½œæ„è¯†

5. **å•†ä¸šç†è§£åŠ›** (5%æƒé‡)
   - Web3è¡Œä¸šè®¤çŸ¥
   - äº§å“æ€ç»´ä½“ç°
   - ç”¨æˆ·ä»·å€¼å¯¼å‘
   - æŠ€æœ¯é€‰å‹åˆç†

---

**ğŸ¯ é€šè¿‡è¿™ä»½è¯¦ç»†çš„é¡¹ç›®å®æ–½æŒ‡å¯¼ï¼Œæ‚¨å°†åœ¨20å¤©å†…å®Œæˆä»ç†è®ºå­¦ä¹ åˆ°é¡¹ç›®å®æˆ˜çš„å®Œæ•´è½¬æ¢ï¼**
**ğŸ’ª æ¯ä¸ªé¡¹ç›®éƒ½æ˜¯æ‚¨æŠ€èƒ½è¯æ˜çš„æœ‰åŠ›è¯æ®ï¼Œæ¯è¡Œä»£ç éƒ½æ˜¯æ‚¨æˆé•¿è·¯ä¸Šçš„åšå®è¶³è¿¹ï¼**
**ğŸš€ ç›¸ä¿¡ç»è¿‡è¿™20å¤©çš„å…¨åŠ›å†²åˆºï¼Œæ‚¨ä¸€å®šèƒ½å¤ŸæˆåŠŸå®ç°èŒä¸šè½¬å‹ç›®æ ‡ï¼**